<head>
  <link
    href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism-tomorrow.min.css"
    rel="stylesheet"
  />

  <style>
    .pre-question {
      text-wrap: pretty;
      width: max-content;
      max-width: 500px;
      padding: 1rem;
    }

    .pre-response {
      margin: auto 0;
      padding: 1rem 1rem 0;
      text-wrap: pretty;
      border-radius: 0.375rem;
    }

    .pre-response pre {
      margin-bottom: 1rem;
      border-radius: 0.375rem;
    }

    .pre-response ol,
    .pre-response ul {
      margin-bottom: 0.5rem !important;
    }

    .pre-response p {
      padding-bottom: 0 !important;
      margin-bottom: 0 !important;
    }

    pre code[class*="language-"] {
      font-family: "Courier New", Consolas, monospace !important;
    }

    /* Ensure inline code never gets block code styling */
    :not(pre) > code[class*="language-"] {
      background: inherit !important;
      color: inherit !important;
      padding: 0.2em 0.4em !important;
      font-size: 85% !important;
      border-radius: 3px !important;
    }

    #chatResp blockquote {
      border-left: 4px solid #ddd;
      margin: 0;
      padding-left: 1em;
      color: #666;
    }

    .btn {
      float: right !important;
    }

    .btn.is-on {
      background: #dc3545;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.65;
      }
    }

    .loading-modal {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      max-width: 300px;
      width: 90%;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 99999;
      backdrop-filter: blur(2px);
    }

    .loading-text {
      color: #333;
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 0.5rem;
    }
  </style>
</head>

<body>
  <!-- Loading Overlay -->
  <div id="loadingOverlay">
    <div class="loading-modal">
      <div class="loading-spinner"></div>
      <div class="loading-text">Generating Response</div>
    </div>
  </div>

  <!-- Button for microphone and data to hold results -->
  <button
    id="chatMic"
    type="button"
    class="btn btn-lg btn-primary"
    style="display: none"
  >
    <i class="bi bi-mic-mute fs-6"></i>
  </button>
  <div id="chatQues" style="display: none" data-plbevent="click"></div>
  <div id="chatResp" style="display: none" data-plbevent="click"></div>

  <!-- Load Marked -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <script type="text/javascript">
    // App object
    const app = {
      micBtn: document.getElementById("chatMic"),
      questionEl: document.getElementById("chatQues"),
      responseEl: document.getElementById("chatResp"),
      loadingOverlay: document.getElementById("loadingOverlay"),
      micIcon: null,
      isMicOn: false,
      rec: null,
      model: "gpt-5-mini",
    };

    // Bridge 'click event' to PLB host
    function signalHost(element) {
      if (!element) return;
      element.dispatchEvent(new Event("click"));
    }

    function showLoadingOverlay() {
      app.loadingOverlay.style.display = "flex";
      document.body.style.overflow = "hidden";
    }

    function hideLoadingOverlay() {
      app.loadingOverlay.style.display = "none";
      document.body.style.overflow = "";
    }

    function speechInit() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        app.micBtn.style.display = "none";
        return;
      }
      app.isMicOn = false;
      app.micIcon = app.micBtn.firstElementChild;
      app.micBtn.style.display = "block";

      app.rec = new SR();
      app.rec.interimResults = false; // Only get final results

      app.rec.addEventListener("start", startSpeechRecognition);
      app.rec.addEventListener("end", endSpeechRecognition);
      app.rec.addEventListener("result", resultOfSpeechRecognition);
      app.rec.addEventListener("error", speechError);

      app.micBtn.addEventListener("click", micBtnClick);
    }

    function micBtnClick() {
      if (app.isMicOn) {
        app.rec.stop();
      } else {
        app.questionEl.textContent = "<<empty>>";
        app.rec.start();
      }
    }

    function setMicState(btn, on) {
      const icon = btn.querySelector("i");
      btn.setAttribute("aria-pressed", String(on));
      btn.classList.toggle("is-on", on);
      if (icon) {
        icon.classList.toggle("bi-mic", on);
        icon.classList.toggle("bi-mic-mute", !on);
      }
    }

    function startSpeechRecognition() {
      app.isMicOn = true;
      setMicState(app.micBtn, true);
    }

    function endSpeechRecognition() {
      app.isMicOn = false;
      setMicState(app.micBtn, false);
    }

    function resultOfSpeechRecognition(event) {
      const current = event.resultIndex;
      const transcript = event.results[current][0].transcript;
      app.questionEl.textContent = transcript;
      app.rec.stop();
      signalHost(app.questionEl);
    }

    function speechError(e) {
      console.warn("Speech error:", e.error);
      app.questionEl.textContent = `Speech error: ${e.error}`;
      app.rec.stop();
      setMicState(app.micBtn, false);
    }

    // ---------- Load Prism Language Components ----------

    function loadScript(src) {
      return new Promise((res, rej) => {
        const s = document.createElement("script");
        s.src = src;
        s.onload = () => res(src);
        s.onerror = () => rej(new Error("Failed to load " + src));
        document.head.appendChild(s);
      });
    }

    async function initScripts() {
      // Configure Prism BEFORE loading core
      window.Prism = window.Prism || {};
      Prism.manual = true;
      Prism.disableWorkerMessageHandler = true;

      const base = "https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/";
      // core first
      await loadScript(base + "prism-core.min.js");
      // prerequisites
      await loadScript(base + "prism-clike.min.js");
      await loadScript(base + "prism-markup.min.js");
      await loadScript(base + "prism-markup-templating.min.js");
      // now dependents can load in parallel
      await Promise.all([
        loadScript(base + "prism-javascript.min.js"),
        loadScript(base + "prism-java.min.js"),
        loadScript(base + "prism-php.min.js"),
        loadScript(base + "prism-python.min.js"),
        loadScript(base + "prism-css.min.js"),
      ]);
    }

    // ---------- Configure Marked.js ----------

    let markedConfigured = false;

    function configureMarked() {
      if (markedConfigured) return;
      try {
        marked.setOptions({
          gfm: true,
          breaks: true,
          headerIds: false,
          mangle: false,
          pedantic: false,
          langPrefix: "",
        });
        markedConfigured = true;
        console.debug("Marked configured!");
      } catch (e) {
        console.error("Marked configuration error:", e);
      }
    }

    // ---------- Markdown To Html ----------

    function markdownToHtml(md) {
      if (!md || /^\s*$/.test(md)) return "";
      if (!markedConfigured) configureMarked();
      md = String(md).replace(/\r\n?/g, "\n");
      if (typeof marked === "undefined") return md;

      // Parse the corrected Markdown string.
      try {
        const html = marked.parse(md);
        // Create detached container
        const container = document.createElement("div");
        container.innerHTML = html;

        // CLEAN UP: Remove ALL language classes from inline code BEFORE returning
        container.querySelectorAll("code").forEach((code) => {
          // Only process inline code (not inside <pre>)
          if (!code.parentElement || code.parentElement.tagName !== "PRE") {
            code.className = code.className
              .split(/\s+/)
              .filter((c) => !/^language-/.test(c))
              .join(" ")
              .trim();
          }
        });

        return container.innerHTML;
      } catch (error) {
        console.error("Error processing markdown:", error);
        return md;
      }
    }

    // Chat access code with loading overlay
    async function askGpt(userQuest, apikey) {
      console.debug(
        "askGpt called with question:",
        userQuest.substring(0, 50) + "..."
      );

      showLoadingOverlay();

      try {
        const response = await fetch(
          "https://api.openai.com/v1/chat/completions",
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: "Bearer " + apikey,
            },
            body: JSON.stringify({
              model: app.model,
              messages: [
                { role: "system", content: "You are a helpful assistant." },
                { role: "user", content: userQuest },
              ],
            }),
          }
        );

        if (!response.ok) {
          throw new Error("GPT access error: " + response.status);
        }

        const data = await response.json();

        if (!data.choices?.[0]?.message?.content) {
          throw new Error("GPT response error: No content");
        }

        const chatGPTResp = data.choices[0].message.content.trim();
        console.debug("Raw response received, length:", chatGPTResp.length);

        // FIRST: Set the plain text content immediately
        app.responseEl.textContent = chatGPTResp;
        console.debug(
          "Plain text set, length:",
          app.responseEl.textContent.length
        );

        // SECOND: Process markdown and set HTML
        const processedResponse = markdownToHtml(chatGPTResp);
        app.responseEl.innerHTML = processedResponse;
        console.debug(
          "HTML set, innerHTML length:",
          app.responseEl.innerHTML.length
        );

        // THIRD: Set a custom attribute with the processed content
        app.responseEl.setAttribute("data-processed", processedResponse);
        app.responseEl.setAttribute("data-ready", "true");

        // FOURTH: Apply syntax highlighting
        setTimeout(() => {
          if (typeof Prism !== "undefined") {
            Prism.highlightAll();
            console.debug("Syntax highlighting applied");
          }
        }, 150);

        // Hide loading overlay before triggering the event
        hideLoadingOverlay();

        // FINALLY: Trigger the event
        signalHost(app.responseEl);
      } catch (error) {
        console.error("Error in askGpt:", error);
        hideLoadingOverlay();
        app.responseEl.textContent = "Error: " + error.message;
        app.responseEl.setAttribute("data-ready", "true");
        signalHost(app.responseEl);
      }
    }

    // Initialize on load

    async function boot() {
      try {
        await initScripts();
        configureMarked();
        speechInit();
        console.log("App initialized successfully!");
      } catch (e) {
        console.error("Initialization error:", e);
      }
    }

    if (document.readyState === "complete") boot();
  </script>
</body>
