<head>
  <title>AI Chat</title>

  <!-- Prism Theme -->
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-core.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <!-- Marked JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- PDF.js -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <!-- Mammoth (docx)-->
  <script defer src="https://unpkg.com/mammoth@1.9.1/mammoth.browser.min.js"></script>
  <!-- Turndown -->
  <script defer src="https://unpkg.com/turndown/dist/turndown.js"></script>
  <script defer src="https://unpkg.com/turndown-plugin-gfm/dist/turndown-plugin-gfm.js"></script>
  <!-- DOMPurify -->
  <script defer src="https://unpkg.com/dompurify/dist/purify.min.js"></script>
  <!-- Bootstrap & Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" />
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>

  <style>
    /*************************************************************
      0) Theme Variables
    **************************************************************/
    :root {
      /* Background Colors */
      --bg-primary: #111827;
      --bg-secondary: #1f2937;
      --bg-tertiary: #374151;
      --bg-accent: #2563eb;
      --bg-bot: #6366f1;

      /* Border & Divider Colors */
      --border-color: #4b5563;

      /* Text Colors */
      --text-primary: #f9fafb;
      --text-secondary: #9ca3af;
      --text-muted: #6b7280;
    }

    /*************************************************************
      1) Base / Resets
    **************************************************************/
    html,
    body {
      height: 100%;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      margin: initial;
      padding: initial;
      font-size: var(--bs-body-font-size, 1rem);
      font-family: var(--bs-font-sans-serif,
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          "Helvetica Neue",
          Arial,
          sans-serif);
      line-height: var(--bs-body-line-height, 1.5);
    }

    html,
    body,
    #C0,
    #C0D {
      overflow-x: hidden;
    }

    /*************************************************************
      2) Layout: App Containers & Global Structure
    **************************************************************/
    /* Root app containers */
    #C0 {
      width: 100vw !important;
      height: 100dvh !important;
      /* dynamic viewport height fixes mobile browser chrome */
    }

    #C0D {
      width: 100% !important;
      height: 100% !important;
    }

    #C2 {
      position: static !important;
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      width: 100% !important;
      min-width: 0 !important;
      overflow-x: hidden !important;
    }

    /* Chat container sizing */
    .chat-container {
      flex: 1 1 auto;
      overflow-y: auto;
    }

    .chat-wrapper {
      box-sizing: border-box;
      max-width: 1024px;
      margin: 0 auto;
      width: 100%;
    }

    main.flex-fill,
    .chat-wrapper.flex-fill,
    .chat-container.flex-fill {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .chat-container.flex-fill {
      flex: 1 1 auto;
      overflow-y: auto;
      min-height: 0;
    }

    /*************************************************************
      3) Structure: Header & Footer
    **************************************************************/
    .app-header,
    .app-footer {
      background-color: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    /* Header layering tweak */
    .app-header {
      position: relative;
      z-index: 1080;
    }

    /*************************************************************
      4) Navigation / Model Picker
    **************************************************************/
    .model-div {
      min-width: 106px;
      max-width: max-content;
    }

    .model-div .form-select,
    .model-div .form-control {
      background-color: var(--bg-primary) !important;
      border: 1px solid var(--border-color) !important;
      color: var(--text-secondary) !important;
    }

    /*************************************************************
      5) Messages: Bubbles, Timestamp, Streaming
    **************************************************************/
    /* Avatar & container */
    .chat-avatar {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--bg-bot);
    }

    .message-bubble {
      word-wrap: break-word;
      position: relative;
      margin-top: 0.375rem;
    }

    /* User & Bot message bubbles */
    .user-message {
      max-width: 78%;
      background-color: var(--bg-accent);
      border-top-right-radius: 0.1rem !important;
    }

    .bot-message {
      max-width: 82%;
      background-color: var(--bg-secondary);
      border-top-left-radius: 0.1rem !important;
    }

    .message-actions {
      width: 100%;
      position: absolute;
      bottom: 0.125rem;
      right: 0.25rem;
    }

    /* Message timestamp (hover to show on bot) */
    .message-timestamp {
      position: absolute;
      top: 2px;
      right: -65px;
      background-color: var(--bg-primary);
      color: var(--text-secondary);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      z-index: 1000;
      backdrop-filter: blur(4px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: opacity 0.2s, visibility 0.2s;
    }

    .bot-message:hover .message-timestamp {
      opacity: 1;
      visibility: visible;
    }

    /* Typing indicator shimmer (streaming) */
    .bot-message.streaming {
      position: relative;
      overflow: hidden;
    }

    .bot-message.streaming .message-content {
      /*min-height: 1.5em;*/
      min-width: 4em;
    }

    .bot-message.streaming .typing-shimmer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      background: linear-gradient(120deg,
          rgba(55, 65, 81, 0) 0%,
          rgba(99, 102, 241, 0.15) 50%,
          rgba(55, 65, 81, 0) 100%);
      animation: shimmer 1.15s infinite linear;
      z-index: 2;
    }

    /* Typing dots indicator */
    .typing-dots {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .typing-dots .dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: var(--text-secondary);
      opacity: 0.5;
      display: inline-block;
      transform-origin: center bottom;
      transform: translateY(0) scale(1);
      will-change: transform, opacity;
      animation: typing-bounce 1.25s cubic-bezier(.34, 1.56, .64, 1) infinite;
    }

    .typing-dots .dot:nth-child(2) {
      animation-delay: 0.15s;
    }

    .typing-dots .dot:nth-child(3) {
      animation-delay: 0.30s;
    }

    /*************************************************************
      6) Message Content: Code, Inline Code, Lists, Headings
    **************************************************************/
    /* Code block wrapper */
    .code-block-wrapper {
      position: relative;
      margin: 0.75rem 0;
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      display: flex;
      flex-direction: column;
    }

    .code-block-wrapper:hover .copy-btn {
      opacity: 1;
    }

    /* Code styling */
    .message-content pre {
      background-color: var(--bg-primary) !important;
      border: none;
      border-bottom-left-radius: 0.375rem;
      border-bottom-right-radius: 0.375rem;
      margin: 0;
      overflow: auto;
      padding: 1rem !important;
    }

    .message-content pre>code {
      display: block;
      padding: 0 0.375rem;
    }

    /* Remove unwanted default code block styling */
    pre[class*="language-"] {
      margin: 0 !important;
    }

    /* Inline code */
    .message-content code:not(pre code) {
      background-color: var(--bg-tertiary);
      color: var(--text-primary);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.875em;
    }

    /* Code block header & lang label */
    .pre-header {
      background-color: var(--bg-primary);
      padding: 0.15rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border-color);
      border-top-left-radius: 0.375rem;
      border-top-right-radius: 0.375rem;
    }

    .code-lang-label {
      user-select: none;
      color: var(--text-secondary);
    }

    /* Lists */
    .message-content ol {
      list-style: none;
      counter-reset: list-counter;
    }

    .message-content ul,
    .message-content ol {
      padding-left: 0.5rem;
    }

    .message-content ol>li {
      counter-increment: list-counter;
      margin-bottom: 0.5rem;
      position: relative;
    }

    .message-content ol>li::before {
      content: counter(list-counter) ".";
      color: var(--bg-bot);
      font-weight: bold;
      margin-right: 0.5rem;
      display: inline-block;
      text-align: right;
    }

    .message-content ul>li {
      margin-bottom: 0.25rem;
      margin-left: 1.25rem;
      position: relative;
    }

    /* Paragraphs & headings */
    .message-content p {
      margin: 0.25rem;
    }

    .message-content li>p {
      display: inline;
    }

    .message-content h1,
    .message-content h2,
    .message-content h3,
    .message-content h4,
    .message-content h5,
    .message-content h6 {
      padding: 0.5rem 0 0.25rem;
      margin-left: 0.4rem;
    }

    /*************************************************************
      7) Inputs & Forms
    **************************************************************/
    .input-area {
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
    }

    .input-area .row>.col-auto:first-child,
    .input-area .row>.col-auto:last-child {
      align-self: flex-end;
    }

    /* General input style */
    .form-control,
    .message-input {
      background-color: var(--bg-secondary) !important;
      border: 1px solid var(--border-color) !important;
      color: var(--text-primary) !important;
    }

    .form-control:focus {
      border-color: var(--bg-bot) !important;
      box-shadow: 0 0 0 0.2rem rgba(99, 102, 241, 0.25) !important;
    }

    .form-control::placeholder,
    .message-input::placeholder {
      color: var(--text-muted);
    }

    /* RAG Settings modal input tweaks */
    #ragSettingsModal .form-control {
      max-width: 150px;
      font-size: 0.85rem;
      padding: 0.25em 0.25em 0.25em 0.5em;
    }

    #ragSettingsModal .form-text {
      margin-left: 4px;
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.125rem;
    }

    #ragSettingsModal .form-label {
      font-size: 0.875rem;
      margin: 0.25em;
    }

    /* Message input specifics */
    .message-input {
      box-sizing: border-box;
      resize: none;
      overflow-y: hidden;
      min-height: 44px;
      max-height: 200px;
      background-color: transparent !important;
      border: none !important;
      line-height: 1.5;
      word-break: break-word;
    }

    .message-input:focus {
      box-shadow: none !important;
      border: none !important;
    }

    /*************************************************************
      8) Buttons & Interactions
    **************************************************************/
    .btn {
      line-height: var(--bs-btn-line-height) !important;
      font-size: var(--bs-btn-font-size) !important;
    }

    .btn-primary {
      background-color: var(--bg-accent);
      border-color: var(--bg-accent);
      transition: all 0.2s ease;
    }

    .btn-primary:hover:not(:disabled) {
      background-color: #1d4ed8;
      border-color: #1d4ed8;
    }

    .btn-primary:disabled {
      background-color: var(--bg-bot);
      border-color: var(--bg-bot);
      cursor: not-allowed;
      opacity: 0.45;
    }

    .btn-primary:not(:disabled) {
      animation: buttonEnable 0.3s ease;
    }

    .btn-secondary {
      background-color: var(--border-color);
      border-color: var(--border-color);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background-color: var(--text-muted);
      border-color: var(--text-muted);
      color: var(--text-primary);
    }

    .btn .bi-trash {
      margin: -0.5rem;
    }

    .btn-clear {
      transition: all 0.2s ease-in-out;
      transform: scale(1.4);
      border: none;
    }

    .btn-clear:hover,
    .btn-clear:focus {
      transform: scale(1.4);
      background-color: var(--bg-secondary);
      color: var(--text-primary);
    }

    #settingsBtn.btn-clear:hover,
    #settingsBtn.btn-clear:focus {
      transform: scale(1.4);
    }

    .btn-outline-secondary {
      color: var(--text-secondary);
    }

    .btn-outline-secondary:hover {
      background-color: var(--bg-secondary);
    }

    .btn-outline-secondary:active,
    .btn-outline-secondary:focus {
      background-color: transparent;
    }

    .btn-modal {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2px 14px;
      margin-left: 10px;
    }

    .btn-retry {
      padding: 0 2px !important;
      font-size: 1rem;
    }

    .btn-resend {
      padding: 0 2px !important;
      font-size: 0.875rem !important;
      margin-left: 0.875rem;
    }

    .btn-resend:hover {
      background-color: var(--bg-bot);
    }

    /* Copy-to-clipboard button */
    .copy-btn {
      z-index: 10;
      opacity: 0.4;
      transition: all 0.2s;
      transform: scale(0.785);
      margin-right: -0.85rem;
    }

    /* Vector deletion button */
    .btn-delete-vector {
      border: none;
      min-width: 1.5rem;
      padding: 0.25rem 0;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 1.5rem;
      transition: transform 0.3s ease;
    }

    .btn-delete-vector:hover {
      background-color: inherit;
      color: inherit;
      transform: scale(1.05);
    }

    /*************************************************************
      9) Dropdowns
    **************************************************************/
    .dropdown-menu {
      margin-bottom: 0.375rem !important;
      min-width: 212px;
      padding: 6px 2px;
      z-index: 1080;
      background-color: var(--bg-secondary) !important;
      border-color: var(--border-color) !important;
    }

    .dropdown-menu .dropdown-item {
      color: var(--text-secondary);
      width: 96%;
      margin: 0 auto 2px;
      padding: 2px 8px;
      font-size: 0.875rem;
      border-radius: 0.3rem;
    }

    .dropdown-divider {
      margin: 6px 0;
      background-color: var(--border-color);
    }

    .dropdown-menu .dropdown-item:hover,
    .dropdown-menu .dropdown-item:focus {
      background-color: var(--bg-tertiary);
    }

    .dropdown-menu .dropdown-item.active,
    .dropdown-menu .dropdown-item:active {
      background-color: var(--bg-tertiary);
    }

    /*************************************************************
      10) Embedding Controls (#embedAddBtn)
    **************************************************************/
    #embedAddBtn {
      width: 32px;
      height: 32px;
      padding: 0;
      transition: transform 0.3s ease;
    }

    #embedAddBtn.btn-outline-secondary:active,
    #embedAddBtn.btn-outline-secondary:focus {
      background-color: transparent;
      color: var(--text-secondary);
      /*box-shadow: none;*/
    }

    #embedAddBtn.btn-outline-secondary:hover {
      background-color: var(--bg-secondary);
    }

    #embedAddBtn[aria-expanded="true"] .bi-plus-lg {
      transform: rotate(45deg);
    }

    #embedAddBtn .bi-plus-lg {
      font-size: 1rem;
      transition: transform 0.3s ease;
    }

    #embedAddBtn .btn-outline-secondary:active,
    #embedAddBtn .btn-outline-secondary:focus {
      background-color: transparent;
    }

    /*************************************************************
      11) Modals & Overlays
    **************************************************************/
    .modal .modal-content {
      background: var(--bg-secondary);
      color: var(--text-primary);
      margin-top: -5.5rem;
    }

    #ragSettingsModal .modal-content {
      margin-top: 8dvh;
    }

    .image-prompt {
      background: var(--bg-tertiary) !important;
    }

    .toast-z {
      z-index: 999999;
    }

    /*************************************************************
      12) Lists / Panels: RAG & Embedding Sources
    **************************************************************/
    /* RAG citations */
    .rag-citations {
      margin-top: 0.75rem;
      padding-top: 0.6rem;
      border-top: 1px solid var(--border-color);
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .rag-citations-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
      color: var(--text-secondary);
    }

    .rag-citations-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 14px;
    }

    .rag-citation {
      white-space: nowrap;
      opacity: 0.95;
    }

    /* Embedding sources list */
    #embeddingSourcesList {
      overflow-y: auto;
      padding: 0.5rem;
      font-size: 0.8rem;
      border: solid 1px var(--border-color) !important;
      color: var(--text-secondary) !important;
    }

    #embeddingSourcesList input[type="checkbox"] {
      margin-top: 5px;
      margin-bottom: 0;
    }

    #embeddingSourcesList .form-check {
      margin-bottom: 0;
    }

    /*************************************************************
      13) Image Mode: Grid Layout & Pills
    **************************************************************/
    /* Image mode: textarea on top, controls below (left/right) */
    .input-area.image-mode .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      /* two columns */
      grid-template-areas:
        "center center"
        /* textarea full width */
        "left   right";
      /* controls row */
      align-items: center;
      gap: 0.5rem 0.5rem;
      /* row-gap / column-gap */
    }

    /* Map existing children to grid areas */
    .input-area.image-mode .row>.col {
      grid-area: center;
    }

    .input-area.image-mode .row>.col-auto:first-child {
      grid-area: left;
      justify-self: start;
      display: flex;
      /* put plus button and pill on same row */
      align-items: center;
      gap: 0.5rem;
      /* spacing between plus and pill */
      flex-wrap: wrap;
      /* wrap if tight space */
    }

    .input-area.image-mode .row>.col-auto:last-child {
      grid-area: right;
      justify-self: end;
    }

    /* Ensure textarea expands nicely */
    .input-area.image-mode #promptInput {
      width: 100%;
    }

    /* Pill container sits in the left controls area, to the right of the plus */
    .mode-pills {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 0.375rem;
    }

    /* Pill styling */
    .pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 0.375rem;
      height: 32px;
      padding: 0.25rem 0.625rem;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
    }

    .pill .close {
      margin-left: 0.275rem;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: none;
      background: transparent;
      color: inherit;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      line-height: 1;
    }

    .pill:hover {
      background-color: var(--bg-secondary);
    }

    .pill .close:focus {
      outline: 2px solid rgba(0, 0, 0, 0.2);
      outline-offset: 1px;
    }

    .pill-icon {
      display: inline-flex;
      align-items: center;
      margin-right: 0.5em;
      vertical-align: middle;
    }

    /*************************************************************
      14) Images & Media Blocks
    **************************************************************/
    .img-block-wrapper {
      position: relative;
      display: inline-block;
      max-width: 100%;
      margin-bottom: 6px;
    }

    .img-block-wrapper>img {
      max-width: 100%;
      border-radius: 7px;
      box-shadow: 0 2px 10px 0 #0001;
    }

    .img-download-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      opacity: 0.75;
      z-index: 20;
      transition: opacity 0.15s ease;
    }

    .img-block-wrapper .img-download-btn {
      border: none;
      outline: none;
      background: rgba(40, 40, 56, 0.65);
      color: #f9fafb;
      border-radius: 0.375rem;
      padding: 0.2rem 0.35rem;
      transition: background 0.18s, opacity 0.22s;
      box-shadow: 0 1px 8px #0002;
    }

    .img-block-wrapper:hover .img-download-btn,
    .img-block-wrapper:focus-within .img-download-btn {
      opacity: 1;
    }

    /*************************************************************
      15) Utilities & Misc
    **************************************************************/
    /* Allow overflow where needed */
    .input-area,
    .chat-wrapper,
    .app-header {
      overflow: visible;
    }

    /* Cursor utilities */
    .cursor-pointer {
      cursor: pointer;
    }

    /*************************************************************
      16) Scrollbars
    **************************************************************/
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /*************************************************************
      17) Tooltips
    **************************************************************/
    .tooltip {
      --bs-tooltip-bg: var(--bg-tertiary);
      --bs-tooltip-color: var(--text-primary);
      --bs-tooltip-border-color: var(--border-color);
      z-index: 5000 !important;
    }

    .tooltip .tooltip-inner {
      background: #292c38;
      color: var(--text-primary);
      border: 1.5px solid var(--border-color);
      border-radius: 0.375rem;
      font-size: 0.8rem;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      padding: 0.5rem 1rem;
    }

    /* Directional tooltip borders */
    .tooltip.bs-tooltip-top .tooltip-arrow::before {
      border-top-color: var(--border-color);
    }

    .tooltip.bs-tooltip-bottom .tooltip-arrow::before {
      border-bottom-color: var(--border-color);
    }

    .tooltip.bs-tooltip-start .tooltip-arrow::before {
      border-left-color: var(--border-color);
    }

    .tooltip.bs-tooltip-end .tooltip-arrow::before {
      border-right-color: var(--border-color);
    }

    .tooltip-arrow {
      z-index: 5000 !important;
    }

    /*************************************************************
      18) Status Indicators
    **************************************************************/
    .status-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
    }

    .status-connecting {
      animation: pulse 1s infinite;
    }

    /*************************************************************
      19) Animations (Keyframes)
    **************************************************************/
    @keyframes buttonEnable {
      from {
        transform: scale(0.95);
        opacity: 0.8;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(99, 102, 241, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(99, 102, 241, 0);
      }
    }

    @keyframes typing-bounce {

      0%,
      80%,
      100% {
        transform: translateY(0) scale(1);
        opacity: 0.35;

      }

      40% {
        transform: translateY(-3px) scale(1.15);
        opacity: 1;

      }
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-90%);
      }

      100% {
        transform: translateX(110%);
      }
    }

    /*************************************************************
      20) Responsive
    **************************************************************/
    /* <= 768px: timestamp nudge */
    @media (max-width: 768px) {
      .message-timestamp {
        top: 3px;
        right: -60px;
        font-size: 0.65rem;
        padding: 2px 5px;
      }
    }

    /* <= 768px: message input & input-area edges */
    @media (max-width: 768px) {
      .message-input {
        max-height: 160px;
      }

      .input-area {
        margin: 0 -0.5rem;
        border-radius: 0.5rem !important;
      }
    }

    /* <= 576px: modal sizing */
    @media (max-width: 576px) {

      /* Bootstrap xs and sm breakpoint */
      .modal-dialog {
        max-width: 75vw;
        margin: 1.75rem auto;
        /* Keep centered with margin */
      }
    }

    /*************************************************************
      21) Effects: Appear/Transitions
    **************************************************************/
    .message-fade-in {
      animation: fadeIn 0.3s ease-in;
    }

    /*************************************************************
      22) Print
    **************************************************************/
    @media print {
      body {
        background: #fff;
        color: #000;
      }
    }
  </style>
</head>

<body class="d-flex flex-column vh-100">
  <!-- Header -->
  <header class="app-header">
    <div class="chat-wrapper">
      <div class="d-flex justify-content-between align-items-center p-3">
        <div class="d-flex">
          <h1 class="m-0 ms-1">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" class="bi bi-openai"
              viewBox="0 0 22 22">
              <path
                d="M14.949 6.547a3.94 3.94 0 0 0-.348-3.273 4.11 4.11 0 0 0-4.4-1.934A4.1 4.1 0 0 0 8.423.2 4.15 4.15 0 0 0 6.305.086a4.1 4.1 0 0 0-1.891.948 4.04 4.04 0 0 0-1.158 1.753 4.1 4.1 0 0 0-1.563.679A4 4 0 0 0 .554 4.72a3.99 3.99 0 0 0 .502 4.731 3.94 3.94 0 0 0 .346 3.274 4.11 4.11 0 0 0 4.402 1.933c.382.425.852.764 1.377.995.526.231 1.095.35 1.67.346 1.78.002 3.358-1.132 3.901-2.804a4.1 4.1 0 0 0 1.563-.68 4 4 0 0 0 1.14-1.253 3.99 3.99 0 0 0-.506-4.716m-6.097 8.406a3.05 3.05 0 0 1-1.945-.694l.096-.054 3.23-1.838a.53.53 0 0 0 .265-.455v-4.49l1.366.778q.02.011.025.035v3.722c-.003 1.653-1.361 2.992-3.037 2.996m-6.53-2.75a2.95 2.95 0 0 1-.36-2.01l.095.057L5.29 12.09a.53.53 0 0 0 .527 0l3.949-2.246v1.555a.05.05 0 0 1-.022.041L6.473 13.3c-1.454.826-3.311.335-4.15-1.098m-.85-6.94A3.02 3.02 0 0 1 3.07 3.949v3.785a.51.51 0 0 0 .262.451l3.93 2.237-1.366.779a.05.05 0 0 1-.048 0L2.585 9.342a2.98 2.98 0 0 1-1.113-4.094zm11.216 2.571L8.747 5.576l1.362-.776a.05.05 0 0 1 .048 0l3.265 1.86a3 3 0 0 1 1.173 1.207 2.96 2.96 0 0 1-.27 3.2 3.05 3.05 0 0 1-1.36.997V8.279a.52.52 0 0 0-.276-.445m1.36-2.015-.097-.057-3.226-1.855a.53.53 0 0 0-.53 0L6.249 6.153V4.598a.04.04 0 0 1 .019-.04L9.533 2.7a3.07 3.07 0 0 1 3.257.139c.474.325.843.778 1.066 1.303.223.526.289 1.103.191 1.664zM5.503 8.575 4.139 7.8a.05.05 0 0 1-.026-.037V4.049c0-.57.166-1.127.476-1.607s.752-.864 1.275-1.105a3.08 3.08 0 0 1 3.234.41l-.096.054-3.23 1.838a.53.53 0 0 0-.265.455zm.742-1.577 1.758-1 1.762 1v2l-1.755 1-1.762-1z" />
            </svg>
          </h1>
          <div class="d-inline-flex align-items-center gap-2 ms-1 model-div">
            <select id="modelPicker" class="form-select form-select-sm">
              <option value="o3">o3</option>
              <option value="o3-mini">o3 mini</option>
              <option value="4o">GPT - 4o</option>
              <option value="4.1" selected>GPT - 4.1</option>
              <option value="4.1-mini" selected>GPT - 4.1 mini</option>
              <option value="5">GPT - 5</option>
              <option value="5-mini">GPT - 5 mini</option>
              <option value="5-nano">GPT - 5 nano</option>
              <option value="5.1">GPT - 5.1</option>             
            </select>
          </div>
        </div>
        <div class="d-flex align-items-center gap-3">
          <button id="settingsBtn" class="btn btn-outline-secondary btn-clear" data-bs-toggle="tooltip"
            data-bs-placement="top" data-bs-title="Rag Settings">
            <i class="bi bi-gear"></i>
          </button>
          <button id="clearChat" class="btn btn-outline-secondary btn-clear" data-bs-toggle="tooltip"
            data-bs-placement="top" data-bs-title="Clear Chat History">
            <i class="bi bi-trash"></i>
          </button>
          <div id="connectionStatus" class="d-flex align-items-center gap-2">
            <div class="status-dot bg-secondary ms-2 me-1"></div>
            <small style="color: var(--text-muted)">Disconnected</small>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Main Chat Area -->
  <main class="flex-fill">
    <div class="chat-wrapper flex-fill">
      <div id="chatContainer" class="chat-container flex-fill p-3">
        <!-- Welcome Message -->
        <div class="d-flex align-items-start gap-3 mb-4 message-fade-in">
          <div class="chat-avatar flex-shrink-0">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
              <path d="M12 8V4H8" />
              <rect width="16" height="12" x="4" y="8" rx="2" />
              <path d="M2 14h2" />
              <path d="M20 14h2" />
              <path d="M15 13v2" />
              <path d="M9 13v2" />
            </svg>
          </div>
          <div class="message-bubble bot-message p-3 rounded">
            <p class="mb-0 small">
              Hello! I'm your AI assistant. Start chatting to get help with any
              questions you have.
            </p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Footer Controls -->
  <footer class="app-footer">
    <div class="chat-wrapper p-3">
      <!-- Message Input -->
      <div class="input-area rounded p-3">
        <div class="row g-2 align-items-center flex-nowrap">
          <!-- LEFT: Plus / Upload -->
          <div class="col-auto">
            <div class="dropdown dropup position-relative d-inline-block">
              <button id="embedAddBtn"
                class="btn btn-outline-secondary d-flex align-items-center justify-content-center"
                data-bs-toggle="dropdown" data-bs-display="static" data-bs-auto-close="true" type="button"
                style="max-height: 32px">
                <i class="bi bi-plus-lg"></i>
              </button>
              <ul class="dropdown-menu cursor-pointer shadow" aria-labelledby="embedAddBtn">
                <li>
                  <button class="dropdown-item" type="button" id="createImage">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor"
                      xmlns="http://www.w3.org/2000/svg" class="icon" aria-label="">
                      <path
                        d="M9.38759 8.53403C10.0712 8.43795 10.7036 8.91485 10.7997 9.59849C10.8956 10.2819 10.4195 10.9133 9.73622 11.0096C9.05259 11.1057 8.4202 10.6298 8.32411 9.94614C8.22804 9.26258 8.70407 8.63022 9.38759 8.53403Z">
                      </path>
                      <path fill-rule="evenodd" clip-rule="evenodd"
                        d="M10.3886 5.58677C10.8476 5.5681 11.2608 5.5975 11.6581 5.74204L11.8895 5.83677C12.4185 6.07813 12.8721 6.46152 13.1991 6.94614L13.2831 7.07993C13.4673 7.39617 13.5758 7.74677 13.6571 8.14048C13.7484 8.58274 13.8154 9.13563 13.8993 9.81919L14.245 12.6317L14.3554 13.5624C14.3852 13.8423 14.4067 14.0936 14.4159 14.3192C14.4322 14.7209 14.4118 15.0879 14.3095 15.4393L14.2606 15.5887C14.0606 16.138 13.7126 16.6202 13.2577 16.9823L13.0565 17.1297C12.7061 17.366 12.312 17.4948 11.8622 17.5877C11.6411 17.6334 11.3919 17.673 11.1132 17.7118L10.1835 17.8299L7.37098 18.1756C6.68748 18.2596 6.13466 18.3282 5.68348 18.3465C5.28176 18.3628 4.9148 18.3424 4.56337 18.2401L4.41395 18.1913C3.86454 17.9912 3.38258 17.6432 3.0204 17.1883L2.87294 16.9872C2.63655 16.6367 2.50788 16.2427 2.41493 15.7928C2.36926 15.5717 2.32964 15.3226 2.29091 15.0438L2.17274 14.1141L1.82704 11.3016C1.74311 10.6181 1.67455 10.0653 1.65614 9.61411C1.63747 9.15518 1.66697 8.74175 1.81141 8.34458L1.90614 8.11313C2.14741 7.58441 2.53115 7.13051 3.01552 6.80356L3.1493 6.71958C3.46543 6.53545 3.8163 6.42688 4.20985 6.34556C4.65206 6.25423 5.20506 6.18729 5.88856 6.10337L8.70106 5.75767L9.63173 5.64731C9.91161 5.61744 10.163 5.59597 10.3886 5.58677ZM6.75673 13.0594C6.39143 12.978 6.00943 13.0106 5.66298 13.1522C5.5038 13.2173 5.32863 13.3345 5.06923 13.5829C4.80403 13.8368 4.49151 14.1871 4.04091 14.6932L3.64833 15.1327C3.67072 15.2763 3.69325 15.4061 3.71766 15.5243C3.79389 15.893 3.87637 16.0961 3.97548 16.243L4.06141 16.3602C4.27134 16.6237 4.5507 16.8253 4.86903 16.9413L5.00477 16.9813C5.1536 17.0148 5.34659 17.0289 5.6288 17.0174C6.01317 17.0018 6.50346 16.9419 7.20888 16.8553L10.0214 16.5106L10.9306 16.3944C11.0173 16.3824 11.0997 16.3693 11.1776 16.3573L8.61513 14.3065C8.08582 13.8831 7.71807 13.5905 7.41395 13.3846C7.19112 13.2338 7.02727 13.1469 6.88856 13.0975L6.75673 13.0594ZM10.4432 6.91587C10.2511 6.9237 10.0319 6.94288 9.77333 6.97056L8.86317 7.07798L6.05067 7.42271C5.34527 7.50932 4.85514 7.57047 4.47841 7.64829C4.20174 7.70549 4.01803 7.76626 3.88173 7.83481L3.75966 7.9061C3.47871 8.09575 3.25597 8.35913 3.1161 8.66587L3.06141 8.79966C3.00092 8.96619 2.96997 9.18338 2.98524 9.55942C3.00091 9.94382 3.06074 10.4341 3.14735 11.1395L3.42274 13.3895L3.64442 13.1434C3.82631 12.9454 3.99306 12.7715 4.1493 12.6219C4.46768 12.3171 4.78299 12.0748 5.16005 11.9208L5.38661 11.8377C5.92148 11.6655 6.49448 11.6387 7.04579 11.7616L7.19325 11.7987C7.53151 11.897 7.8399 12.067 8.15907 12.2831C8.51737 12.5256 8.9325 12.8582 9.4452 13.2684L12.5966 15.7889C12.7786 15.6032 12.9206 15.3806 13.0106 15.1336L13.0507 14.9979C13.0842 14.8491 13.0982 14.6561 13.0868 14.3739C13.079 14.1817 13.0598 13.9625 13.0321 13.704L12.9247 12.7938L12.58 9.9813C12.4933 9.27584 12.4322 8.78581 12.3544 8.40903C12.2972 8.13219 12.2364 7.94873 12.1679 7.81235L12.0966 7.69028C11.9069 7.40908 11.6437 7.18669 11.3368 7.04673L11.203 6.99204C11.0364 6.93147 10.8195 6.90059 10.4432 6.91587Z">
                      </path>
                      <path
                        d="M9.72841 1.5897C10.1797 1.60809 10.7322 1.67665 11.4159 1.7606L14.2284 2.1063L15.1581 2.22446C15.4371 2.26322 15.6859 2.3028 15.9071 2.34849C16.3571 2.44144 16.7509 2.57006 17.1015 2.80649L17.3026 2.95396C17.7576 3.31618 18.1055 3.79802 18.3056 4.34751L18.3544 4.49692C18.4567 4.84845 18.4772 5.21519 18.4608 5.61704C18.4516 5.84273 18.4292 6.09381 18.3993 6.37388L18.2899 7.30454L17.9442 10.117C17.8603 10.8007 17.7934 11.3535 17.702 11.7958C17.6207 12.1895 17.5122 12.5401 17.328 12.8563L17.244 12.9901C17.0958 13.2098 16.921 13.4086 16.7255 13.5829L16.6171 13.662C16.3496 13.8174 16.0009 13.769 15.787 13.5292C15.5427 13.255 15.5666 12.834 15.8407 12.5897L16.0018 12.4276C16.0519 12.3703 16.0986 12.3095 16.1415 12.2459L16.2128 12.1239C16.2813 11.9875 16.3421 11.8041 16.3993 11.5272C16.4771 11.1504 16.5383 10.6605 16.6249 9.95493L16.9696 7.14243L17.077 6.23228C17.1047 5.97357 17.1239 5.7546 17.1317 5.56235C17.1432 5.27997 17.1291 5.08722 17.0956 4.93833L17.0556 4.80259C16.9396 4.4842 16.7381 4.20493 16.4745 3.99497L16.3573 3.90903C16.2103 3.80991 16.0075 3.72745 15.6386 3.65122C15.4502 3.61231 15.2331 3.57756 14.9755 3.54185L14.0663 3.42563L11.2538 3.08091C10.5481 2.99426 10.0582 2.93444 9.67372 2.9188C9.39129 2.90732 9.19861 2.92142 9.0497 2.95493L8.91395 2.99497C8.59536 3.11093 8.31538 3.31224 8.10536 3.57603L8.0204 3.69321C7.95293 3.79324 7.89287 3.91951 7.83778 4.10532L7.787 4.23032C7.64153 4.50308 7.31955 4.64552 7.01161 4.55454C6.65948 4.45019 6.45804 4.07952 6.56239 3.72739L6.63075 3.52036C6.70469 3.31761 6.79738 3.12769 6.91786 2.94907L7.06532 2.7479C7.42756 2.29294 7.90937 1.94497 8.45888 1.74497L8.60829 1.69614C8.95981 1.59385 9.32655 1.57335 9.72841 1.5897Z">
                      </path>
                    </svg>
                    <span class="ms-1">Create image</span>
                  </button>
                </li>
                <li>
                  <hr class="dropdown-divider" />
                </li>
                <li>
                  <button class="dropdown-item" type="button" id="addContextBtn">
                    <i class="bi bi-journal-text me-2"></i>
                    Add file as context
                  </button>
                </li>
                <li>
                  <label class="dropdown-item" for="manageInputBtn" id="addEmbedding">
                    <i class="bi bi-file-earmark-arrow-up me-2"></i>
                    Add files for embeddings
                    <input id="manageInputBtn" type="file" class="d-none" multiple
                      accept=".txt,.md,.htm,.html,.pdf,.docx" />
                  </label>
                </li>
                <li>
                  <hr class="dropdown-divider" />
                </li>
                <li>
                  <button class="dropdown-item text-danger" type="button" id="deleteFileContextBtn">
                    <i class="bi bi-x-circle me-2"></i>
                    Delete file context
                  </button>
                </li>
                <li>
                  <button class="dropdown-item text-danger" type="button" id="deleteAllEmbeddingsBtn">
                    <i class="bi bi-trash3 me-2"></i>
                    Delete all embeddings
                  </button>
                </li>
              </ul>
            </div>
          </div>

          <!-- CENTER: Textarea -->
          <div class="col">
            <textarea id="promptInput" class="form-control message-input w-100"
              placeholder="Type your message ... (Shift+Enter for new line)" rows="1"></textarea>
          </div>

          <!-- RIGHT: Send button -->
          <div class="col-auto">
            <button id="sendBtn" class="btn btn-primary d-flex align-items-center gap-1" style="max-height: 32px">
              <i class="bi bi-send"></i>
              <span>Send</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Status Bar -->
      <div class="d-flex justify-content-between align-items-center mt-2">
        <small id="statusText" style="color: var(--text-muted)">Ready</small>
        <small id="docStatus" style="color: var(--text-muted)"></small>
        <small id="messageCount" style="color: var(--text-muted)">0 messages</small>
      </div>
    </div>
  </footer>

  <!-- Rag Settings Modal -->
  <div class="modal fade" id="ragSettingsModal" tabindex="-1" aria-labelledby="ragSettingsModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <form class="modal-content" id="ragSettingsForm">
        <div class="modal-header">
          <h6 class="modal-title" id="ragSettingsModalLabel">RAG Settings</h6>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="row gy-2 gx-3">
            <div class="col-6">
              <label for="ragTopK" class="form-label">Top K</label>
              <input type="number" class="form-control" id="ragTopK" min="1" max="32" step="1" />
              <div class="form-text">How many chunks to consider.</div>
            </div>
            <div class="col-6">
              <label for="ragMinSim" class="form-label">Min Similarity</label>
              <input type="number" class="form-control" id="ragMinSim" min="0" max="1" step="0.01" />
              <div class="form-text">Cosine threshold 0 -> 1.</div>
            </div>
            <div class="col-6">
              <label for="ragChunkTokens" class="form-label">Chunk Size (tokens)</label>
              <input type="number" class="form-control" id="ragChunkTokens" min="200" max="8192" step="20" />
              <div class="form-text">
                Max tokens per chunk when creating embeddings.
              </div>
            </div>
            <div class="col-6">
              <label for="ragBudgetTokens" class="form-label">Budget Tokens</label>
              <input type="number" class="form-control" id="ragBudgetTokens" min="1000" max="64000" step="100" />
              <div class="form-text">Total tokens across snippets.</div>
            </div>
            <div class="col-6">
              <label for="ragOverlapTokens" class="form-label">Overlap Tokens</label>
              <input type="number" class="form-control" id="ragOverlapTokens" min="0" max="1024" step="4" />
              <div class="form-text">
                Number of tokens to overlap between consecutive chunks.
              </div>
            </div>

            <div class="col-6">
              <label for="ragMinSnippetTokens" class="form-label">Min Snippet Tokens</label>
              <input type="number" class="form-control" id="ragMinSnippetTokens" min="50" max="1000" step="50" />
              <div class="form-text">Minimum tokens per snippet.</div>
            </div>

            <div id="embedding-sources-wrapper" class="col-12">
              <label class="form-label">Embedded Sources to Include</label>
              <div id="embeddingSourcesList" class="border rounded p-2">
                <!-- JS will populate checkboxes as form-check items here -->
              </div>
              <div id="embeddingStatus" class="form-text mt-1">
                <!-- Shows count like "Using 2 embedded files" -->
              </div>
            </div>
          </div>
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-secondary btn-modal" data-bs-dismiss="modal">
            Cancel
          </button>
          <button type="submit" class="btn btn-primary btn-modal">Apply</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Toast -->
  <div id="appToast" class="toast align-items-center text-bg-primary border-0 position-fixed top-0 end-0 m-3 toast-z"
    role="alert" aria-live="assertive" aria-atomic="true">
    <div class="d-flex">
      <div class="toast-body" id="appToastBody">
        <!-- Message goes here -->
      </div>
      <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"
        aria-label="Close"></button>
    </div>
  </div>

  <!-- Bootstrap Confirm Clear Modal -->
  <div class="modal fade" id="clearChatModal" tabindex="-1" aria-labelledby="clearChatModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-sm">
      <div class="modal-content">
        <div class="modal-header d-flex w-100 justify-content-center position-relative">
          <h5 class="modal-title mx-auto" id="clearChatModalLabel">
            Clear All Chat?
          </h5>
          <button type="button" class="btn-close position-absolute end-0 top-0 mt-2 me-2" data-bs-dismiss="modal"
            aria-label="Close"></button>
        </div>
        <div class="modal-footer">
          <button type="button" id="cancelClearChatBtn" class="btn btn-secondary btn-modal" data-bs-dismiss="modal">
            Cancel
          </button>
          <button type="button" id="confirmClearChatBtn" class="btn btn-primary btn-modal">
            Yes, clear
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap confirm delete modal -->
  <div class="modal fade" id="confirmDeleteModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title mx-auto">
            Confirm
          </h5>
        </div>
        <div class="modal-body mx-auto" id="confirmDeleteModalBody">
          Are you sure?
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary btn-modal" data-bs-dismiss="modal">
            Cancel
          </button>
          <button type="button" class="btn btn-primary btn-modal" id="confirmModalOk">
            Yes
          </button>
        </div>
      </div>
    </div>
  </div>


  <script>

    // ---------------------------------------------------------------
    // 1. CONSTANTS & CONFIGURATION
    // ---------------------------------------------------------------

    const SYSTEM_PROMPT = `
	You are ChatGPT, an expert assistant for a chat application. Your main functions are:
	- Providing accurate general knowledge.
	- Offering extensive help with programming, web development, and all major coding languages.
	
	**Response Formatting Guidelines:**
	1. For programming, configuration, or technical markup examples:
	   - Always wrap examples in fenced code blocks with the correct language identifier 
	     (e.g., \`\`\`python, \`\`\`javascript, \`\`\`html, \`\`\`bash, \`\`\`yaml).
	   - For code or technical output not fitting a standard language, use a \`\`\`text code block.
	2. When you show Markdown examples that contain triple-backtick fences, use four backticks for the outer code fence.
	3. For general knowledge or non-coding replies:
	   - Use concise, readable Markdown (e.g., lists, tables, bold or italic text), focusing on clarity for users.
	4. Never use raw or rendered markup outside of code fences. All technical or code-based content must be inside properly labeled code blocks.
	5. Always tailor formatting to the subject: code and technical data in code blocks; all other information in easy-to-read Markdown.
	6. If special expertise is requested, you are also an expert in Sunbelt PLB, visual plb (PL/B - Programming Language for Business) -> provide accurate, detailed help for this language when needed.
	
	**Overall:**
	- Maximize clarity and readability in all responses for users.
	`;

    const CONTEXT_INSTRUCTIONS = {
      base: `### Task:
	Respond to the user query using the provided context, incorporating inline citations in the format [id] when referencing specific retrieved snippets.
	
	### Guidelines:
	- If you don't know the answer, clearly state that.
	- If uncertain, ask the user for clarification.
	- Respond in the same language as the user's query.
	- If the context is unreadable or of poor quality, inform the user and provide the best possible answer.
	- If the answer isn't present in the context but you possess the knowledge, explain this to the user and provide the answer using your own understanding.
	- **Only include inline citations using [id] when referencing specific retrieved snippets with provided IDs.**
	- Do not cite general knowledge or document background without a snippet ID.
	- Ensure citations are concise and directly related to the information provided.`,

      docOnly: `### Additional Context Notes:
	- The uploaded document provides background context and is referenced contextually as "the document" or "the uploaded file."
	- Do not use [id] format for document citations (it has no snippet IDs).`,

      ragOnly: `### Additional Context Notes:
	- Retrieved snippets are ranked by relevance (similarity score) and labeled with IDs [1], [2], etc.
	- Each snippet includes its source file and chunk index for reference.
	- Only cite using [id] when directly referencing a specific snippet.
	- Higher-ranked snippets (lower IDs) are more relevant to your query.`,

      hybrid: `### Additional Context Notes:
	- Uploaded document: Reference contextually as "the document" (no [id] citations—it's background context).
	- Retrieved snippets: Cite as [1], [2], etc. when referencing specific relevant snippets with their IDs.
	- Each snippet includes its source file and chunk index.
	- Prefer snippet citations [id] for specific facts; use document for general background.
	- If sources conflict, acknowledge both perspectives.`,
    };

    const robotSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
                          <path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/>
                        </svg>`;
    const userSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
                         <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/>
                         </svg>`;

    const copySVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-copy px-1" viewBox="0 0 16 16">
			  <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1z"/>
			</svg>`;
    const checkSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
			  <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>
			</svg>`;
    const downloadSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16">
			  <path d="M.5 9.9V14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V9.9a.5.5 0 0 0-1 0V14a1 1 0 0 1-1 1H2.5a1 1 0 0 1-1-1V9.9a.5.5 0 0 0-1 0z"/>
			  <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793l-2.146-2.147a.5.5 0 0 0-.708.708l3 3z"/>
			</svg>`;
    const stopSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16">
			  <rect width="10" height="10" x="3" y="3" rx="2"/>
			</svg>`;
    const imageSVG = `<svg width="16" height="16" viewBox="0 0 20 20" fill="currentColor"
			xmlns="http://www.w3.org/2000/svg" class="icon" aria-label="">
                      	<path d="M9.38759 8.53403C10.0712 8.43795 10.7036 8.91485 10.7997 9.59849C10.8956 10.2819 10.4195 10.9133 9.73622 11.0096C9.05259 11.1057 8.4202 10.6298 8.32411 9.94614C8.22804 9.26258 8.70407 8.63022 9.38759 8.53403Z"
                      	></path>
                      	<path fill-rule="evenodd" clip-rule="evenodd"
                        d="M10.3886 5.58677C10.8476 5.5681 11.2608 5.5975 11.6581 5.74204L11.8895 5.83677C12.4185 6.07813 12.8721 6.46152 13.1991 6.94614L13.2831 7.07993C13.4673 7.39617 13.5758 7.74677 13.6571 8.14048C13.7484 8.58274 13.8154 9.13563 13.8993 9.81919L14.245 12.6317L14.3554 13.5624C14.3852 13.8423 14.4067 14.0936 14.4159 14.3192C14.4322 14.7209 14.4118 15.0879 14.3095 15.4393L14.2606 15.5887C14.0606 16.138 13.7126 16.6202 13.2577 16.9823L13.0565 17.1297C12.7061 17.366 12.312 17.4948 11.8622 17.5877C11.6411 17.6334 11.3919 17.673 11.1132 17.7118L10.1835 17.8299L7.37098 18.1756C6.68748 18.2596 6.13466 18.3282 5.68348 18.3465C5.28176 18.3628 4.9148 18.3424 4.56337 18.2401L4.41395 18.1913C3.86454 17.9912 3.38258 17.6432 3.0204 17.1883L2.87294 16.9872C2.63655 16.6367 2.50788 16.2427 2.41493 15.7928C2.36926 15.5717 2.32964 15.3226 2.29091 15.0438L2.17274 14.1141L1.82704 11.3016C1.74311 10.6181 1.67455 10.0653 1.65614 9.61411C1.63747 9.15518 1.66697 8.74175 1.81141 8.34458L1.90614 8.11313C2.14741 7.58441 2.53115 7.13051 3.01552 6.80356L3.1493 6.71958C3.46543 6.53545 3.8163 6.42688 4.20985 6.34556C4.65206 6.25423 5.20506 6.18729 5.88856 6.10337L8.70106 5.75767L9.63173 5.64731C9.91161 5.61744 10.163 5.59597 10.3886 5.58677ZM6.75673 13.0594C6.39143 12.978 6.00943 13.0106 5.66298 13.1522C5.5038 13.2173 5.32863 13.3345 5.06923 13.5829C4.80403 13.8368 4.49151 14.1871 4.04091 14.6932L3.64833 15.1327C3.67072 15.2763 3.69325 15.4061 3.71766 15.5243C3.79389 15.893 3.87637 16.0961 3.97548 16.243L4.06141 16.3602C4.27134 16.6237 4.5507 16.8253 4.86903 16.9413L5.00477 16.9813C5.1536 17.0148 5.34659 17.0289 5.6288 17.0174C6.01317 17.0018 6.50346 16.9419 7.20888 16.8553L10.0214 16.5106L10.9306 16.3944C11.0173 16.3824 11.0997 16.3693 11.1776 16.3573L8.61513 14.3065C8.08582 13.8831 7.71807 13.5905 7.41395 13.3846C7.19112 13.2338 7.02727 13.1469 6.88856 13.0975L6.75673 13.0594ZM10.4432 6.91587C10.2511 6.9237 10.0319 6.94288 9.77333 6.97056L8.86317 7.07798L6.05067 7.42271C5.34527 7.50932 4.85514 7.57047 4.47841 7.64829C4.20174 7.70549 4.01803 7.76626 3.88173 7.83481L3.75966 7.9061C3.47871 8.09575 3.25597 8.35913 3.1161 8.66587L3.06141 8.79966C3.00092 8.96619 2.96997 9.18338 2.98524 9.55942C3.00091 9.94382 3.06074 10.4341 3.14735 11.1395L3.42274 13.3895L3.64442 13.1434C3.82631 12.9454 3.99306 12.7715 4.1493 12.6219C4.46768 12.3171 4.78299 12.0748 5.16005 11.9208L5.38661 11.8377C5.92148 11.6655 6.49448 11.6387 7.04579 11.7616L7.19325 11.7987C7.53151 11.897 7.8399 12.067 8.15907 12.2831C8.51737 12.5256 8.9325 12.8582 9.4452 13.2684L12.5966 15.7889C12.7786 15.6032 12.9206 15.3806 13.0106 15.1336L13.0507 14.9979C13.0842 14.8491 13.0982 14.6561 13.0868 14.3739C13.079 14.1817 13.0598 13.9625 13.0321 13.704L12.9247 12.7938L12.58 9.9813C12.4933 9.27584 12.4322 8.78581 12.3544 8.40903C12.2972 8.13219 12.2364 7.94873 12.1679 7.81235L12.0966 7.69028C11.9069 7.40908 11.6437 7.18669 11.3368 7.04673L11.203 6.99204C11.0364 6.93147 10.8195 6.90059 10.4432 6.91587Z"
                      	></path>
                      	<path d="M9.72841 1.5897C10.1797 1.60809 10.7322 1.67665 11.4159 1.7606L14.2284 2.1063L15.1581 2.22446C15.4371 2.26322 15.6859 2.3028 15.9071 2.34849C16.3571 2.44144 16.7509 2.57006 17.1015 2.80649L17.3026 2.95396C17.7576 3.31618 18.1055 3.79802 18.3056 4.34751L18.3544 4.49692C18.4567 4.84845 18.4772 5.21519 18.4608 5.61704C18.4516 5.84273 18.4292 6.09381 18.3993 6.37388L18.2899 7.30454L17.9442 10.117C17.8603 10.8007 17.7934 11.3535 17.702 11.7958C17.6207 12.1895 17.5122 12.5401 17.328 12.8563L17.244 12.9901C17.0958 13.2098 16.921 13.4086 16.7255 13.5829L16.6171 13.662C16.3496 13.8174 16.0009 13.769 15.787 13.5292C15.5427 13.255 15.5666 12.834 15.8407 12.5897L16.0018 12.4276C16.0519 12.3703 16.0986 12.3095 16.1415 12.2459L16.2128 12.1239C16.2813 11.9875 16.3421 11.8041 16.3993 11.5272C16.4771 11.1504 16.5383 10.6605 16.6249 9.95493L16.9696 7.14243L17.077 6.23228C17.1047 5.97357 17.1239 5.7546 17.1317 5.56235C17.1432 5.27997 17.1291 5.08722 17.0956 4.93833L17.0556 4.80259C16.9396 4.4842 16.7381 4.20493 16.4745 3.99497L16.3573 3.90903C16.2103 3.80991 16.0075 3.72745 15.6386 3.65122C15.4502 3.61231 15.2331 3.57756 14.9755 3.54185L14.0663 3.42563L11.2538 3.08091C10.5481 2.99426 10.0582 2.93444 9.67372 2.9188C9.39129 2.90732 9.19861 2.92142 9.0497 2.95493L8.91395 2.99497C8.59536 3.11093 8.31538 3.31224 8.10536 3.57603L8.0204 3.69321C7.95293 3.79324 7.89287 3.91951 7.83778 4.10532L7.787 4.23032C7.64153 4.50308 7.31955 4.64552 7.01161 4.55454C6.65948 4.45019 6.45804 4.07952 6.56239 3.72739L6.63075 3.52036C6.70469 3.31761 6.79738 3.12769 6.91786 2.94907L7.06532 2.7479C7.42756 2.29294 7.90937 1.94497 8.45888 1.74497L8.60829 1.69614C8.95981 1.59385 9.32655 1.57335 9.72841 1.5897Z"
                      	></path>
                      </svg>`;

    const LANG_ALIASES = {
      js: "javascript",
      mjs: "javascript",
      cjs: "javascript",
      jsx: "jsx",
      tsx: "tsx",
      ts: "typescript",
      sh: "bash",
      shell: "bash",
      zsh: "bash",
      console: "bash",
      postgres: "sql",
      postgresql: "sql",
      yml: "yaml",
      md: "markdown",
      text: "none",
      plaintext: "none",
      json5: "json",
      jsonc: "json",
      env: "ini",
      dotenv: "ini",
      docker: "docker",
      dockerfile: "docker",
      xml: "markup",
      svg: "markup",
      mathml: "markup",
      xhtml: "markup",
      gql: "graphql",
      graphql: "graphql",
      ps: "powershell",
      ps1: "powershell",
      // Build/infra
      make: "makefile",
      makefile: "makefile",
      // Config
      properties: "ini",
      conf: "ini",
      cfg: "ini",
      toml: "toml",
      // Popular languages
      py: "python",
      rb: "ruby",
      php: "php",
      java: "java",
      cs: "csharp",
      "c#": "csharp",
      c: "c",
      "c++": "cpp",
      cpp: "cpp",
      objc: "objectivec",
      "objective-c": "objectivec",
      swift: "swift",
      go: "go",
      rs: "rust",
      rust: "rust",
      kt: "kotlin",
      kotlin: "kotlin",
      plb: "plb",
      "pl/b": "plb",
    };
    // Minimal filename/extension support
    const FILE_EXT_TO_LANG = {
      js: "javascript",
      mjs: "javascript",
      cjs: "javascript",
      ts: "typescript",
      jsx: "jsx",
      tsx: "tsx",
      json: "json",
      json5: "json",
      yml: "yaml",
      yaml: "yaml",
      toml: "toml",
      ini: "ini",
      env: "ini",
      html: "markup",
      htm: "markup",
      xml: "markup",
      svg: "markup",
      css: "css",
      scss: "scss",
      less: "less",
      sh: "bash",
      bash: "bash",
      zsh: "bash",
      py: "python",
      rb: "ruby",
      php: "php",
      java: "java",
      cs: "csharp",
      c: "c",
      h: "c",
      cpp: "cpp",
      hpp: "cpp",
      go: "go",
      rs: "rust",
      kt: "kotlin",
      swift: "swift",
      md: "markdown",
      markdown: "markdown",
      gql: "graphql",
      graphql: "graphql",
    };

    // Special filename cases
    const FILENAME_TO_LANG = {
      dockerfile: "docker",
      Dockerfile: "docker",
      makefile: "makefile",
      Makefile: "makefile",
      ".env": "ini",
    };

    // Language dependency map for Prism
    const PRISM_DEPS = {
      // bases
      markup: [],
      clike: [],
      javascript: ["clike"],
      typescript: ["javascript"],
      jsx: ["markup", "javascript"],
      tsx: ["jsx", "typescript"],

      // languages that extend clike
      java: ["clike"],
      c: ["clike"],
      cpp: ["c"],
      objectivec: ["c"],
      csharp: ["clike"],
      kotlin: ["clike"],
      swift: ["clike"],
      go: ["clike"],

      // styles
      scss: ["css"],
      less: ["css"],

      // templating
      php: ["clike", "markup", "markup-templating"],

      // markup-adjacent
      markdown: ["markup"],
    };

    // Prism languages that don't exist or shouldn't be loaded
    const SKIP_LANGUAGES = new Set(["none", "plb", "text", "plaintext", "plain"]);

    const TOAST_TYPE_MAP = {
      error: "danger",
      warn: "warning",
      warning: "warning",
      info: "primary",
      success: "success",
    };

    // Prism base URL for loading components
    const BASE_URL = "https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/";

    // Helpers for safe link rendering
    const SAFE_PROTOCOLS = new Set(["http:", "https:", "mailto:", "tel:"]);

    // Works in browser and SSR
    const BASE_ORIGIN =
      typeof window !== "undefined" && window.location && window.location.origin
        ? window.location.origin
        : "http://localhost";

    const DROPDOWN_MIN_OPEN_TIME = 150;

    const WAIT_CONFIG = {
      PRISM: {
        timeoutMs: 6000,
        intervalMs: 100
      },
      PRISM_AUTOLOADER: {
        timeoutMs: 2000,
        intervalMs: 50
      },
      MARKED: {
        timeoutMs: 6000,
        intervalMs: 100
      },
      PDFJS: {
        timeoutMs: 5000,
        intervalMs: 100
      },
      DEFAULT: {
        timeoutMs: 6000,
        intervalMs: 100
      },
      CONDITION: {
        timeoutMs: 2000,
        intervalMs: 50
      }
    };

    // === IndexedDB for Embeddings ===
    const EMBED_DB_NAME = "embeddingsDB";
    const EMBED_STORE_NAME = "vectors";
    const EMBED_DB_VERSION = 2;

    // ---------------------------------------------------------------
    // 2. CORE STATE
    // ---------------------------------------------------------------

    const chatApp = {
      messageCount: 0,
      messageHistory: [
      	{
      	  role: "system",
      	  content: SYSTEM_PROMPT,
	}
      ],
      maxHistory: 16,
      images: [],
      els: {},
      models: {
        o3: {
          id: "o3",
          tokenField: "max_output_tokens",
          defaultMax: 32768,
          reasoning: { effort: "medium"},
        },
        "o3-mini": {
          id: "o3-mini",
          tokenField: "max_output_tokens",
          defaultMax: 32768,
          reasoning: { effort: "medium"},
        },
        "4o": { id: "gpt-4o", tokenField: "max_output_tokens", defaultMax: 16384 },
        4.1: { id: "gpt-4.1", tokenField: "max_output_tokens", defaultMax: 32768 },
        "4.1-mini": {
          id: "gpt-4.1-mini",
          tokenField: "max_output_tokens",
          defaultMax: 32768,
        },
        5: {
          id: "gpt-5",
          tokenField: "max_output_tokens",
          defaultMax: 32768,
          reasoning: { effort: "medium"},  // default is medium, use high for extended thinking or complex tasks
        },
        "5-mini": {
          id: "gpt-5-mini",
          tokenField: "max_output_tokens",
          defaultMax: 32768,
        },
        "5-nano": {
          id: "gpt-5-nano",
          tokenField: "max_output_tokens",
          defaultMax: 32768,
        },
        5.1: {
          id: "gpt-5.1",
          tokenField: "max_output_tokens",
          defaultMax: 32768,
          reasoning: { effort: "medium"},  // default is "none" -> "none" | "low" | "medium" | "high"
        },        
      },
      embedding: {
        model: "text-embedding-3-small",
        batchSize: 32,
      },
      ragPresets: {
        default: {
          budgetTokens: 16000,
          minSnippetTokens: 250,
          topK: 12,
          minSim: 0.25,
          chunkingTokens: 800,
          overlapTokens: 48,
        },
        "gpt-5.1": {
          budgetTokens: 60000,
          minSnippetTokens: 300,
          topK: 16,
          minSim: 0.25,
          chunkingTokens: 1200,
          overlapTokens: 64,
        },
        "gpt-5": {
          budgetTokens: 60000,
          minSnippetTokens: 300,
          topK: 16,
          minSim: 0.25,
          chunkingTokens: 1200,
          overlapTokens: 64,
        },
        "gpt-5-mini": {
          budgetTokens: 32000,
          minSnippetTokens: 250,
          topK: 14,
          minSim: 0.28,
          chunkingTokens: 800,
          overlapTokens: 48,
        },
      },
      rag: null,
      currentModelKey: "5.1",
      currentController: null,
      currentReader: null,
      isStreaming: false,
      _stopping: false,
      markedConfigured: false,
      apiKey: "",
      docContext: "",
      docName: "",
      maxDocChars: 200000, // Prevents token limit issues
      _eventsBound: false, // One-time guard to prevent duplicate bind
      isImagePrompt: false,
    };
    chatApp.isImagePrompt = !!chatApp.isImagePrompt; // normalize to boolean

    // Save/restore original HTML for send button
    const originalSendBtnHTML = `<i class="bi bi-send"></i><span> Send </span>`;

    // ---------------------------------------------------------------
    // 3. UTILITY FUNCTIONS (no dependencies on other functions)
    // ---------------------------------------------------------------

    // Helper function for event binding
    const addListener = (element, event, handler, options = {}) => {
      element?.addEventListener(event, handler, options);
    };

    // Modal Creation Helper
    const getOrCreateModal = (element, options = { focus: false }) =>
      bootstrap.Modal.getOrCreateInstance(element, options);

    const initTooltipElements = (TooltipClass) => {
      document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach((el) => {
        TooltipClass.getInstance?.(el)?.dispose();
        new TooltipClass(el, { trigger: "hover", container: "body" });
      });
    };

    const showConfirm = async (
      message,
      {
        modalId = 'confirmDeleteModal',
        bodySelector = '#confirmDeleteModalBody',
        okSelector = '#confirmModalOk',
        title,
        okText,
        cancelText,
        cancelSelector = '[data-bs-dismiss="modal"]',
      } = {}
    ) => {
      const modalEl = document.getElementById(modalId);
      if (!modalEl) throw new Error(`Modal #${modalId} not found`);

      const setElementText = (selector, text) => {
        if (text !== undefined) {
          const el = modalEl.querySelector(selector);
          if (el) el.textContent = text;
        }
      };

      setElementText(bodySelector, message ?? 'Are you sure?');
      setElementText('.modal-title', title);
      setElementText(okSelector, okText);
      setElementText(cancelSelector, cancelText);

      const okBtn = modalEl.querySelector(okSelector);
      const cancelBtn = modalEl.querySelector(cancelSelector);
      const bsModal = getOrCreateModal(modalEl);

      return new Promise((resolve) => {
        const onOk = () => {
          resolve(true);
          bsModal.hide();
        };

        const onHide = () => {
          resolve(false);
        };

        addListener(okBtn, 'click', onOk, { once: true });
        addListener(modalEl, 'hidden.bs.modal', onHide, { once: true });
        bsModal.show();
      });
    };

    const escapeHtml = (s) => {
      if (s == null) return "";
      return String(s).replace(
        /[&<>"']/g,
        (m) =>
        ({
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
        }[m])
      );
    };

    const isSafeHref = (href) => {
      if (!href) return false;

      // Trim and strip control chars/whitespace that can smuggle protocols
      const cleaned = String(href)
        .trim()
        .replace(/[\u0000-\u001F\u007F\s]+/g, "");

      // Internal anchors and same-origin relatives
      if (cleaned.startsWith("#") || cleaned.startsWith("/")) return true;

      try {
        const url = new URL(cleaned, BASE_ORIGIN);
        return SAFE_PROTOCOLS.has(url.protocol);
      } catch {
        return false;
      }
    };

    const getBaseName = (pathOrFile) => {
      if (!pathOrFile) return "unknown";
      const raw =
        typeof pathOrFile === "string"
          ? pathOrFile
          : (pathOrFile && pathOrFile.name) || "";
      const parts = String(raw).split(/[\\/]/);
      return parts[parts.length - 1] || "unknown";
    };

    const cosineSim = (a, b) => {
      let dot = 0,
        normA = 0,
        normB = 0;

      a.forEach((valA, i) => {
        const valB = b[i];
        dot += valA * valB;
        normA += valA * valA;
        normB += valB * valB;
      });

      return dot / (Math.sqrt(normA) * Math.sqrt(normB));
    };

    const clampInt = (v, min, max, fallback) => {
      v = Number.isFinite(+v) ? Math.round(+v) : fallback;
      return Math.min(max, Math.max(min, v));
    };

    const clampNum = (v, min, max, fallback) => {
      v = Number.isFinite(+v) ? +v : fallback;
      return Math.min(max, Math.max(min, v));
    };

    // Abort error helper
    const isAbortLike = (err) => {
      return (
        !!err &&
        (err.name === "AbortError" ||
          /aborted/i.test(String(err.message || "")))
      );
    };

    // Timestamp
    const formatTimestamp = (date) => {
      const now = new Date();
      const isToday = date.toDateString() === now.toDateString();

      return isToday
        ? date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        })
        : date.toLocaleString([], {
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
    };

    const sanitizeArrayOfNames = (arr) => {
      if (!Array.isArray(arr)) return [];
      return arr
        .map((s) => (typeof s === "string" ? s.trim() : ""))
        .filter(Boolean);
    };

    // Normalize a file name (and handle strings or File objects)
    const normalizeName = (nameOrFile) => {
      const name =
        typeof nameOrFile === "string"
          ? nameOrFile
          : (nameOrFile && nameOrFile.name) || "";
      return String(name || "").toLowerCase();
    };

    // Load Prism fallback
    const inFlightLoads = new Map();

    const loadPrismLanguage = async (language) => {
      if (!language || SKIP_LANGUAGES.has(language)) return `Skipped ${language}`;
      if (window.Prism?.languages?.[language]) return `${language} already loaded`;
      if (inFlightLoads.has(language)) return inFlightLoads.get(language);

      const url = `${BASE_URL}prism-${language}.min.js`;

      const p = new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = url;
        s.async = false;
        s.onload = () => resolve(`${language} loaded`);
        s.onerror = () => reject(new Error(`Failed to load ${language}`));
        document.head.appendChild(s);
      }).finally(() => inFlightLoads.delete(language));

      inFlightLoads.set(language, p);
      return p;
    };

    const loadLanguageWithDeps = async (language, seen = new Set()) => {
      const lang = normalizeLanguage(language);
      if (!lang || SKIP_LANGUAGES.has(lang) || seen.has(lang)) return;
      seen.add(lang);

      const deps = PRISM_DEPS[lang] || [];
      for (const dep of deps) {
        await loadLanguageWithDeps(dep, seen);
      }
      return loadPrismLanguage(lang);
    };

    // Ensure Prism core exists
    const ensurePrismCore = async () => {
      if (window.Prism) return;
      await loadPrismLanguage("core"); // loads components/prism-core.min.js
    };

    // include base languages first
    const commonLanguages = [
      "markup",
      "clike",
      "javascript",
      "typescript",
      "jsx",
      "json",
      "css",
      "sql",
      "bash",
      "php",
      "ruby",
      "go",
      "rust",
      "markdown",
      "yaml",
      "c",
      "python",
    ];

    const loadPrismLanguages = async (languages = commonLanguages) => {
      await ensurePrismCore();

      const results = [];
      for (const lang of languages) {
        try {
          const r = await loadLanguageWithDeps(lang);
          if (r) results.push(r);
        } catch (e) {
          console.warn(`Failed to load ${lang}:`, e.message);
        }
      }
      console.log(`Loaded ${results.length} languages:`, languages);
      return results;
    };

    // Load languages for a specific code block's language string
    const loadLanguageForCode = async (infostring) => {
      const lang = normalizeLanguage(infostring);
      if (lang && !SKIP_LANGUAGES.has(lang)) {
        return await loadLanguageWithDeps(lang);
      }
    };

    // ---- Manual highlighting as last resort ----
    const manualHighlightAll = (container) => {
      const blocks = container.querySelectorAll("pre code");
      blocks.forEach((code) => {
        try {
          Prism.highlightElement(code);
        } catch (e) {
          // Best-effort; continue
          console.warn("highlightElement failed:", e);
        }
      });
    };

    // ---------------------------------------------------------------
    // 4. TOKEN & TEXT PROCESSING
    // ---------------------------------------------------------------

    const { model, batchSize } = chatApp.embedding;

    // Estimate # tokens (rough)
    const estimateTokens = (text) => {
      if (!text) return 0;
      const words = text.trim().split(/\s+/).filter(Boolean).length;
      return Math.max(1, Math.round(words * 1.3));
    };

    const sliceByTokenEstimate = (text, maxTokens) => {
      if (!text) return "";
      let lo = 0,
        hi = text.length,
        ans = 0;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const prefix = text.slice(0, mid);
        if (estimateTokens(prefix) <= maxTokens) {
          ans = mid;
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }
      return text.slice(0, ans);
    };

    // Chunk large text
    const chunkTextByTokens = (text, maxTokens, overlap) => {
      if (!text) return [];

      // Prefer explicit args; fallback to rag settings; then fallback to hard-coded constants.
      const max =
        typeof maxTokens === "number"
          ? maxTokens
          : chatApp.rag?.chunkingTokens || 800;
      const ov =
        typeof overlap === "number"
          ? overlap
          : chatApp.rag?.overlapTokens || 48;

      const paragraphs = text
        .split(/\n\s*\n/)
        .map((p) => p.trim())
        .filter(Boolean);
      const chunks = [];
      let currentParts = [];
      let currentTokens = 0;

      const flushCurrent = () => {
        if (currentParts.length === 0) return;
        const chunkText = currentParts.join("\n\n").trim();
        chunks.push({ text: chunkText, tokens: currentTokens });
        currentParts = [];
        currentTokens = 0;
      };

      for (const p of paragraphs) {
        const tTokens = estimateTokens(p);
        if (tTokens > max) {
          const lines = p
            .split("\n")
            .map((l) => l.trim())
            .filter(Boolean);
          let buf = [];
          let bufTokens = 0;
          for (const l of lines) {
            const lTokens = estimateTokens(l);
            if (bufTokens + lTokens > max) {
              if (buf.length) {
                currentParts.push(buf.join("\n"));
                currentTokens = estimateTokens(currentParts.join("\n\n"));
                flushCurrent();
              }
              if (lTokens > max) {
                const words = l.split(/\s+/);
                let wbuf = [];
                for (const w of words) {
                  if (
                    estimateTokens(wbuf.join(" ")) + estimateTokens(w) >
                    max
                  ) {
                    chunks.push({
                      text: wbuf.join(" "),
                      tokens: estimateTokens(wbuf.join(" ")),
                    });
                    wbuf = [w];
                  } else {
                    wbuf.push(w);
                  }
                }
                if (wbuf.length)
                  chunks.push({
                    text: wbuf.join(" "),
                    tokens: estimateTokens(wbuf.join(" ")),
                  });
              } else {
                chunks.push({ text: l, tokens: lTokens });
              }
              buf = [];
              bufTokens = 0;
            } else {
              buf.push(l);
              bufTokens += lTokens;
            }
          }
          if (buf.length) {
            currentParts.push(buf.join("\n"));
            currentTokens = estimateTokens(currentParts.join("\n\n"));
          }
        } else {
          if (currentTokens + tTokens + 2 > max) {
            flushCurrent();
            currentParts.push(p);
            currentTokens = tTokens;
          } else {
            currentParts.push(p);
            currentTokens += tTokens + 2;
          }
        }
      }
      flushCurrent();

      // Overlap logic (optional)
      if (ov > 0 && chunks.length > 1) {
        const takeWords = Math.round(ov / 1.3) || 30;
        const overlapped = chunks.map((chunk, idx, arr) => {
          let txt = chunk.text;
          if (idx > 0) {
            const prevWords = arr[idx - 1].text.split(/\s+/).filter(Boolean);
            const slice = prevWords.slice(-takeWords).join(" ");
            txt = slice + "\n\n" + txt;
          }
          return { text: txt, tokens: estimateTokens(txt) };
        });
        return overlapped;
      }
      return chunks;
    };

    // Trim text to stay within token limits
    const trimContext = (text, maxChars = chatApp.maxDocChars) => {
      return text.length > maxChars ? text.slice(0, maxChars) : text;
    };

    // ---------------------------------------------------------------
    // 5. FILE & DOCUMENT PROCESSING
    // ---------------------------------------------------------------

    // --- DRY: file kind detection ---
    const getFileKind = (file) => {
      const name = normalizeName(file);
      const mime = file && file.type ? String(file.type).toLowerCase() : "";

      if (mime.includes("pdf") || name.endsWith(".pdf")) return "pdf";
      if (mime.includes("word") || name.endsWith(".docx")) return "docx";
      if (name.endsWith(".doc")) return "doc"; // not supported in-browser
      if (
        mime.includes("html") ||
        name.endsWith(".html") ||
        name.endsWith(".htm")
      )
        return "html";
      if (name.endsWith(".md")) return "md";
      if (name.endsWith(".txt")) return "txt";
      return "other";
    };

    // Map file kind to Bootstrap Icon class (v1.11)
    const iconClass = (nameOrPath) => {
      switch (getFileKind(nameOrPath)) {
        case "pdf":
          return "bi-file-earmark-pdf";
        case "docx":
          return "bi-file-earmark-word";
        case "md":
          return "bi-file-earmark-markdown";
        case "markdown":
          return "bi-file-earmark-markdown";
        case "txt":
          return "bi-file-earmark-text";
        case "html":
          return "bi-file-earmark-code";
        default:
          return "bi-file-earmark";
      }
    };

    const isSupportedForEmbed = (nameOrFile) => {
      const name = normalizeName(nameOrFile);
      return /\.(txt|md|htm|html|pdf|docx)$/i.test(name);
    };

    // Keep divs! legacy .htm pages wrap content in <div>
    const sanitizeHtml = (html) => {
      if (typeof DOMPurify !== "undefined") {
        const cleaned = DOMPurify.sanitize(html, {
          WHOLE_DOCUMENT: false,
          ALLOWED_TAGS: [
            "p",
            "br",
            "ul",
            "ol",
            "li",
            "em",
            "strong",
            "b",
            "i",
            "u",
            "code",
            "pre",
            "a",
            "aside",
            "table",
            "thead",
            "tbody",
            "tr",
            "th",
            "td",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "span",
            "div",
            "font",
            "center",
            "blockquote",
            "title",
          ],
          ALLOWED_ATTR: ["href", "colspan", "rowspan"],
          FORBID_TAGS: ["script", "style"],
          FORBID_ATTR: [/^on/i],
        });
        return cleaned.replace(/\u00A0/g, " ");
      }
      console.warn("DOMPurify not found; falling back to raw text extraction.");
      return String(html || "").replace(/\u00A0/g, " ");
    };

    // Convert HTML to compact text for embeddings (robust traversal + title fallback)
    const htmlToEmbeddableText = (html) => {
      // Precompiled regexes to avoid reallocation in hot paths
      const RE_SPACE = /\s+/g;
      const RE_ALNUM = /[A-Za-z0-9]/;
      const RE_SEE_ALSO = /^\s*See Also:/i;

      // 1) Sanitize once
      const cleaned = sanitizeHtml(html);
      const doc = new DOMParser().parseFromString(cleaned, "text/html");

      // Optional: prepend <title> as heading if useful (legacy .htm often lacks <h1>)
      const pageTitle = (doc.querySelector("title")?.textContent || "").trim();

      // 2) Remove empty/nav tables
      Array.from(doc.querySelectorAll("table")).forEach((table) => {
        const text = table.textContent.replace(RE_SPACE, "");
        const hasMeaningfulText = RE_ALNUM.test(text);
        if (!hasMeaningfulText) table.remove();
      });

      // 3) Drop "See Also" paragraphs
      Array.from(doc.querySelectorAll("p")).forEach((p) => {
        if (RE_SEE_ALSO.test(p.textContent)) p.remove();
      });

      // ---- helpers ----
      const collectInlineText = (el) => {
        const parts = [];
        const skipTags = new Set(["TABLE", "UL", "OL", "TR", "THEAD", "TBODY", "TFOOT"]);

        const walk = (n) => {
          if (n.nodeType === Node.TEXT_NODE) {
            const t = n.nodeValue.replace(RE_SPACE, " ");
            if (t.trim()) parts.push(t);
            return;
          }
          if (n.nodeType !== Node.ELEMENT_NODE) return;
          const name = n.nodeName;
          if (skipTags.has(name)) return;
          if (name === "BR") {
            parts.push("\n"); // kept: later collapsed to space by join/replace, matching original behavior
            return;
          }
          Array.from(n.childNodes).forEach(walk);
        };

        walk(el);
        return parts.join(" ").replace(RE_SPACE, " ").trim();
      };

      const flattenTable = (table) => {
        const lines = [];
        const rows = Array.from(table.querySelectorAll("tr"));
        if (!rows.length) return lines;

        // Detect a "Code / Description" header
        let start = 0;
        let codeDesc = false;
        const hdrCells = rows[0].querySelectorAll("th,td");
        if (hdrCells.length >= 2) {
          const hdrText = (hdrCells[0].textContent + " " + hdrCells[1].textContent).toLowerCase();
          if (hdrText.includes("code") && hdrText.includes("description")) {
            codeDesc = true;
            start = 1;
          }
        }

        for (let i = start; i < rows.length; i++) {
          const cells = Array.from(rows[i].querySelectorAll("td,th"));
          if (!cells.length) continue;

          if (codeDesc && cells.length >= 2) {
            const key = collectInlineText(cells[0]).replace(/^\W+|\W+$/g, "");
            const val = collectInlineText(cells[1]);
            if (key && val) {
              lines.push(`${key}: ${val}`);
            } else {
              const txt = cells.map((c) => collectInlineText(c)).filter(Boolean).join(" | ");
              if (txt) lines.push(txt);
            }
          } else {
            const txt = cells.map((c) => collectInlineText(c)).filter(Boolean).join(" | ");
            if (txt) lines.push(txt);
          }
        }
        return lines;
      };

      const out = [];

      const traverse = (node) => {
        if (!node) return;

        if (node.nodeType === Node.TEXT_NODE) {
          const t = node.nodeValue.replace(RE_SPACE, " ").trim();
          if (t) out.push(t);
          return;
        }
        if (node.nodeType !== Node.ELEMENT_NODE) return;

        const name = node.nodeName;

        // Emit in reading order
        if (/^H[1-6]$/.test(name)) {
          const t = collectInlineText(node);
          if (t) out.push(t);
          return;
        }
        if (name === "P") {
          const t = collectInlineText(node);
          if (t) out.push(t);
          return;
        }
        if (name === "UL" || name === "OL") {
          Array.from(node.querySelectorAll(":scope > li")).forEach((li) => {
            const t = collectInlineText(li);
            if (t) out.push("- " + t);
          });
          return;
        }
        if (name === "TABLE") {
          const lines = flattenTable(node);
          lines.forEach((l) => out.push(l));
          return;
        }
        if (name === "PRE" || name === "CODE") {
          const t = node.textContent.replace(RE_SPACE, " ").trim();
          if (t) out.push(t);
          return;
        }

        // Default: continue depth-first to preserve order
        Array.from(node.childNodes).forEach(traverse);
      };

      traverse(doc.body || doc);

      const lines = out.map((s) => s.replace(RE_SPACE, " ").trim()).filter(Boolean);

      // Prepend <title> if present and not already included
      if (pageTitle && (!lines.length || lines[0] !== pageTitle)) {
        lines.unshift(pageTitle);
      }
      return lines.join("\n");
    };

    const normalizeTables = (html) => {
      const doc = new DOMParser().parseFromString(html, "text/html");

      // 1) Promote first row <td> to <th> so GFM table rule recognizes a header
      doc.querySelectorAll("table").forEach((table) => {
        const firstRow = table.querySelector("tr");
        if (firstRow && !firstRow.querySelector("th")) {
          firstRow.querySelectorAll("td").forEach((td) => {
            const th = doc.createElement("th");
            th.innerHTML = td.innerHTML;
            td.replaceWith(th);
          });
        }
        // 2) Unwrap single <p> wrappers inside cells
        table.querySelectorAll("td, th").forEach((cell) => {
          if (
            cell.children.length === 1 &&
            cell.firstElementChild.tagName === "P"
          ) {
            cell.innerHTML = cell.firstElementChild.innerHTML;
          }
        });
      });

      return doc.body.innerHTML;
    };

    const stripEmptyAnchors = (html) => {
      const doc = new DOMParser().parseFromString(html, "text/html");
      doc.querySelectorAll("a").forEach((a) => {
        if (!a.getAttribute("href")) {
          const span = doc.createElement("span");
          span.innerHTML = a.innerHTML;
          a.replaceWith(span);
        }
      });
      return doc.body.innerHTML;
    };

    const dropEmptyNavTables = (html) => {
      const doc = new DOMParser().parseFromString(html, "text/html");
      doc.querySelectorAll("table").forEach((table) => {
        const text = table.textContent.replace(/\s+/g, "");
        const hasMeaningfulText = /[A-Za-z0-9]/.test(text);
        if (!hasMeaningfulText) table.remove();
      });
      return doc.body.innerHTML;
    };

    const normalizeHeadings = (html) => {
      const doc = new DOMParser().parseFromString(html, "text/html");
      doc.querySelectorAll("p.BannerBase")?.forEach((p) => {
        const h = doc.createElement("h1");
        h.textContent = p.textContent.trim();
        p.replaceWith(h);
      });
      return doc.body.innerHTML;
    };

    const htmlToMarkdown = (html) => {
      const td = new TurndownService({
        codeBlockStyle: "fenced",
        headingStyle: "atx",
        bulletListMarker: "-",
      });

      if (typeof turndownPluginGfm !== "undefined") {
        td.use(turndownPluginGfm.gfm);
      }

      // Keep paragraphs inside table cells as line breaks so GFM tables don't split
      td.addRule("paragraphInTableCell", {
        filter: (node) =>
          node.nodeName === "P" &&
          node.parentNode &&
          /^(TD|TH)$/i.test(node.parentNode.nodeName),
        replacement: (content) => (content ? content + "<br>" : ""),
      });

      // Optional: lists inside cells ? single cell lines separated by <br>
      td.addRule("listInTableCell", {
        filter: (node) =>
          /^(UL|OL)$/i.test(node.nodeName) &&
          node.parentNode &&
          /^(TD|TH)$/i.test(node.parentNode.nodeName),
        replacement: (content, node) => {
          const items = Array.from(node.querySelectorAll(":scope > li")).map(
            (li) => li.textContent.trim()
          );
          return items.map((it) => "- " + it).join("<br>");
        },
      });

      return td.turndown(html);
    };

    // --- DRY: unified text extraction for DOC CONTEXT or EMBEDDINGS ---
    const extractTextFor = async (file, { purpose = "doc" } = {}) => {
      let kind = getFileKind(file);
      // Debug: log file decision
      console.log(
        "[extractTextFor] file:",
        file?.name,
        "mime:",
        file?.type,
        "initialKind:",
        kind
      );

      // If we couldn't detect but it looks like HTML by mime or content, treat as html
      if (kind === "other") {
        const mime = file && file.type ? String(file.type).toLowerCase() : "";
        if (mime.includes("html")) {
          kind = "html";
          console.log(
            "[extractTextFor] fallback to html via mime for",
            file?.name
          );
        } else {
          // quick content sniff: read small prefix to see if it's HTML-like
          try {
            const txt = await file.slice(0, 512).text();
            if (
              /^\s*<!doctype\s+html|^\s*<html|^\s*<meta\s+charset/i.test(txt)
            ) {
              kind = "html";
              console.log(
                "[extractTextFor] fallback to html via content sniff for",
                file?.name
              );
            }
          } catch (e) {
            // ignore content sniff errors; proceed with original kind
          }
        }
      }

      if (kind === "pdf") {
        if (typeof pdfjsLib === "undefined")
          throw new Error("PDF.js not loaded");
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const pageTexts = await Promise.all(
          Array.from({ length: pdf.numPages }, async (_, idx) => {
            const page = await pdf.getPage(idx + 1);
            const textContent = await page.getTextContent();
            return textContent.items.map((it) => it.str).join(" ");
          })
        );
        return pageTexts.join("\n\n").trim();
      }

      if (kind === "docx") {
        if (!window.mammoth) throw new Error("Mammoth (DOCX) not loaded");
        const arrayBuffer = await file.arrayBuffer();
        const { value: rawText } = await mammoth.extractRawText({
          arrayBuffer,
        });
        return (rawText || "").replace(/\u0000/g, "").trim();
      }

      if (kind === "doc") {
        throw new Error(
          "Legacy .doc not supported in-browser. Resave as DOCX."
        );
      }

      if (kind === "html") {
        let html = await file.text();

        // Log raw prefix to help debug
        //console.log(`[extractTextFor/html] raw file prefix (${file.name})`);

        html = sanitizeHtml(html);

        // Log after sanitize
        console.log(
          `[extractTextFor/html] sanitized length: ${html.length} for ${file.name}`
        );

        if (purpose === "embed") {
          // Flatter, compact text for embeddings
          html = stripEmptyAnchors(html);
          html = dropEmptyNavTables(html);
          html = normalizeHeadings(html);

          const embText = htmlToEmbeddableText(html);
          console.log(
            `[extractTextFor/html] embeddable length: ${embText.length} for ${file.name}`
          );
          console.log(`[extractTextFor/html] embeddable text:`, embText);

          // Fallback: if embeddable text is empty, use a plain text fallback
          if (!embText || !embText.trim()) {
            console.warn(
              `[extractTextFor/html] embeddableText empty for ${file.name}, falling back to textContent extraction`
            );
            // Quick fallback: parse sanitized HTML and extract visible text
            try {
              const doc = new DOMParser().parseFromString(html, "text/html");
              if (!doc || !doc.body) {
                console.warn(`Failed to parse HTML for ${file.name}`);
                return "";
              }
              // remove script/style/iframe/frameset if present
              doc
                .querySelectorAll("script,style,iframe,frameset")
                .forEach((n) => n.remove());
              const txtFallback = Array.from(
                doc.body.querySelectorAll("p,div,li,span,td,th,h1,h2,h3,h4")
              )
                .map((el) => el.textContent.trim())
                .filter(Boolean)
                .join("\n\n");

              const fallback =
                txtFallback.trim() ||
                doc.body.textContent.replace(/\s+/g, " ").trim();
              console.log(
                `[extractTextFor/html] fallback length: ${fallback.length} for ${file.name}`
              );
              return fallback;
            } catch (e) {
              console.error(
                "[extractTextFor/html] fallback extraction error:",
                e
              );
              return ""; // let later code handle empty text
            }
          }

          return embText;
        } else {
          // human-readable doc context (Markdown-friendly)
          html = normalizeTables(html); // promote first row to <th>, unwrap <p> in cells
          html = normalizeHeadings(html);
          const md = htmlToMarkdown(html);
          console.log(
            `[extractTextFor/html] markdown length: ${md.length} for ${file.name}`
          );
          return md;
        }
      }

      // TXT/MD/other: treat as plain text
      return (await file.text()).replace(/\u0000/g, "").trim();
    };

    // ---------------------------------------------------------------
    // 6. UI STATE MANAGEMENT (depends on utilities)
    // ---------------------------------------------------------------

    // API key functions
    const setApiKey = (key) => {
      if (!key) {
        throw new Error("API key cannot be empty");
      }
      chatApp.apiKey = key;
      return true;
    };

    const getApiKey = () => {
      if (!chatApp.apiKey) {
        showToast(
          "Please enter your API key in the settings to use this feature.",
          { type: "warning", delay: 5500 }
        );
        throw new Error("API key not configured. Call setApiKey() first.");
      }
      return chatApp.apiKey;
    };

    // Helper: get active model config
    const getActiveModelConfig = () => {
      return chatApp.models[chatApp.currentModelKey] || chatApp.models["5.1"];
    };

    // Show a Bootstrap toast with safe defaults
    const hideTimer = Symbol("toastHideTimer");

    const showToast = (
      message,
      { type = "primary", delay = 4000, autohide = true } = {}
    ) => {

      const toast = document.getElementById("appToast");
      if (!toast) return;

      // Prefer element-scoped lookup to avoid a second global id
      const toastBody =
        toast.querySelector(".toast-body") ||
        document.getElementById("appToastBody");
      if (!toastBody) return;

      // Ensure in body (avoid container issues)
      if (toast.parentNode !== document.body) {
        document.body.appendChild(toast);
      }

      // Normalize type and map to Bootstrap contextual class
      const normType = String(type || "primary").toLowerCase();
      const bsType = TOAST_TYPE_MAP[normType] || normType || "primary";

      // Keep classes and only swap the context class
      toast.classList.add(
        "toast",
        "align-items-center",
        "border-0",
        "position-fixed",
        "top-0",
        "end-0",
        "m-3",
        "toast-z"
      );

      // Remove previous text-bg-* class if present, then add new one
      for (const c of Array.from(toast.classList)) {
        if (c.startsWith("text-bg-")) toast.classList.remove(c);
      }
      toast.classList.add(`text-bg-${bsType}`);

      // Accessibility
      if (!toast.hasAttribute("role")) toast.setAttribute("role", "status");
      if (!toast.hasAttribute("aria-live")) toast.setAttribute("aria-live", "polite");

      toastBody.textContent = String(message ?? "");

      const safeDelay = Math.max(0, Number(delay) || 0);
      const ToastCtor = window.bootstrap?.Toast;

      if (ToastCtor) {
        // Reuse a single instance and manage timers ourselves
        const instance = ToastCtor.getOrCreateInstance(toast, {
          animation: true,
          autohide: false // avoid Bootstrap's internal timer to prevent race conditions
        });

        instance.show();

        // Restart our own hide timer on every call
        if (toast[hideTimer]) clearTimeout(toast[hideTimer]);
        if (autohide) {
          toast[hideTimer] = setTimeout(() => {
            // Guard if the element was removed from DOM
            if (!document.body.contains(toast)) return;
            instance.hide();
          }, safeDelay);
        }
      } else {
        // Fallback: emulate Bootstrap's show/autohide behavior
        toast.classList.add("show");
        if (toast[hideTimer]) clearTimeout(toast[hideTimer]);
        if (autohide) {
          toast[hideTimer] = setTimeout(() => {
            toast.classList.remove("show");
          }, safeDelay);
        }
      }
    };

    // Global tooltip management object
    const tooltipManager = {
      activeTooltip: null,
      element: null,

      // Clean up any existing tooltip completely
      dispose() {
        if (this.activeTooltip) {
          try {
            this.activeTooltip.dispose();
          } catch (error) {
            console.warn("Error disposing tooltip:", error);
          }
          this.activeTooltip = null;
        }

        // Clean up orphaned tooltip elements
        const tooltips = document.querySelectorAll(".tooltip");
        tooltips.forEach((tip) => tip.remove());

        if (this.element) {
          this.element.removeAttribute("aria-describedby");
          this.element.removeAttribute("data-bs-original-title");
        }
      },

      // Create a new tooltip
      create(element, text, options = {}) {
        if (!element) return null;

        this.dispose(); // Always clean up first
        this.element = element;

        element.setAttribute("data-bs-title", text);
        element.setAttribute("title", "");

        const defaultOptions = {
          trigger: "hover",
          container: "body",
          ...options,
        };

        try {
          this.activeTooltip = new bootstrap.Tooltip(element, defaultOptions);
          return this.activeTooltip;
        } catch (error) {
          console.warn("Error creating tooltip:", error);
          return null;
        }
      },

      // Show tooltip with text (creates if needed)
      show(element, text) {
        if (!element) return;

        const tooltip = this.create(element, text);
        if (tooltip) {
          try {
            tooltip.show();
          } catch (error) {
            console.warn("Error showing tooltip:", error);
          }
        }
      },

      // Hide current tooltip without disposing (avoids Bootstrap errors)
      hide() {
        if (this.activeTooltip && this.element) {
          try {
            // Instead of calling hide() which causes the error,
            // we'll just dispose and clean up manually
            this.dispose();
          } catch (error) {
            console.warn("Error hiding tooltip:", error);
          }
        }
      },
    };

    const updateStatus = (message) => {
      chatApp.els.statusText.textContent = message;
    };

    const updateMessageCount = () => {
      const history = chatApp.messageHistory || [];
      const visible = history.filter((m) => m && m.role === "assistant").length;

      const el = chatApp.els?.messageCount;
      if (el) {
        const label = visible === 1 ? "message" : "messages";
        el.textContent = `${visible} ${label}`;
      }
    };

    const updateDocStatus = () => {
      // debug
      //	console.log("updateDocStatus called", {
      //	  docName: chatApp.docName,
      //	  docContextLen: chatApp.docContext?.length || 0,
      //	  ragSources: Array.from(chatApp.ragSources || []),
      //	  enabledRagSources: Array.from(chatApp.enabledRagSources || []),
      //	});

      const el = document.getElementById("docStatus");
      if (!el) return;

      const parts = [];

      // Show doc context if present
      if (chatApp.docContext) {
        const shortName =
          chatApp.docName.length > 18
            ? chatApp.docName.substring(0, 17) + "..."
            : chatApp.docName;
        parts.push(
          `Doc: ${shortName} (${chatApp.docContext.length.toLocaleString()} chars)`
        );
      }

      // Prefer showing number of *selected* embedding sources if available
      if (chatApp.enabledRagSources?.size > 0) {
        const selectedSources = Array.from(chatApp.enabledRagSources);
        if (selectedSources.length === 1) {
          const shortName =
            selectedSources[0].length > 18
              ? selectedSources[0].substring(0, 17) + "..."
              : selectedSources[0];
          parts.push(`Using embedded: ${shortName}`);
        } else {
          parts.push(
            `Using embedded: ${selectedSources.length} file${selectedSources.length !== 1 ? "s" : ""
            }`
          );
        }
      }
      // If enabledRagSources is empty, fall back to all embedded sources count
      else if (chatApp.ragSources?.size > 0) {
        const sources = Array.from(chatApp.ragSources);
        if (sources.length === 1) {
          const shortName =
            sources[0].length > 18
              ? sources[0].substring(0, 17) + "..."
              : sources[0];
          parts.push(`Embedded: ${shortName}`);
        } else {
          parts.push(`Embedded: ${sources.length} files`);
        }
      }

      el.textContent = parts.join(" | ");
    };

    // Connection status updates
    const updateConnectionStatus = (status) => {
      const statusEl = chatApp.els.connectionStatus;
      if (!statusEl) return;

      const dot = statusEl.querySelector(".status-dot");
      const text = statusEl.querySelector("small");

      if (!dot || !text) return;

      // Reset classes: keep only 'status-dot'
      dot.className = "status-dot";

      switch (status) {
        case "connected":
          dot.classList.add("bg-success");
          text.textContent = "Connected";
          break;
        case "connecting":
          dot.classList.add("bg-warning", "status-connecting");
          text.textContent = "Connecting";
          break;
        default:
          dot.classList.add("bg-secondary");
          text.textContent = "Disconnected";
      }
    };

    // hideTooltip function
    const hideTooltip = (element) => {
      if (!element) return;
      tooltipManager.hide();
    };

    // Blur the focused element if it's inside a specific modal element
    const blurFocusedInModal = (modalEl) => {
      if (!modalEl) return false;

      let blurred = false;
      // If the modal itself has focus
      if (
        modalEl === document.activeElement &&
        typeof modalEl.blur === "function"
      ) {
        modalEl.blur();
        blurred = true;
      }

      // If some descendant is focused
      const focusedInside = modalEl.querySelector(":focus");
      if (focusedInside && typeof focusedInside.blur === "function") {
        focusedInside.blur();
        blurred = true;
      }

      // Fallback: check activeElement containment
      if (
        !blurred &&
        document.activeElement &&
        modalEl.contains(document.activeElement)
      ) {
        const el = document.activeElement;
        if (typeof el.blur === "function") {
          el.blur();
          blurred = true;
        }
      }
      return blurred;
    };

    // Blur focus inside all currently open Bootstrap modals
    const blurAllOpenModals = () => {
      document.querySelectorAll(".modal.show").forEach(blurFocusedInModal);
    };

    // ---------------------------------------------------------------
    // 7. CITATIONS & SOURCE MANAGEMENT UI
    // ---------------------------------------------------------------

    // Generate the HTML string for a single citation.
    const generateCitationItem = (group) => {
      const filename = getBaseName(group.source || "");
      const icon = iconClass(filename);
      const sortedIdxs = group.idxs.slice().sort((a, b) => a - b);

      // Escape the full source for use in the title attribute (tooltip)
      const fullSourceTitle = escapeHtml(group.source || "");

      return `
        <div class="rag-citation" title="${fullSourceTitle}">
            <span 
                class="bi ${icon}" 
                aria-hidden="true" 
                style="display:inline-block; margin:0 6px 0 0; vertical-align:middle;">
            </span>
            ${escapeHtml(filename)} [${sortedIdxs.join(",")}]
        </div>
    `;
    };

    // Append citations, grouped by file with per-file indices shown.
    // If dedupe is true, group by source; otherwise fall back to per-citation rendering.
    const appendCitations = (messageEl, citations, { dedupe = true } = {}) => {
      try {
        if (!messageEl || !Array.isArray(citations) || citations.length === 0)
          return;

        const contentEl = messageEl.querySelector(".message-content");
        if (!contentEl) return;

        // Remove prior citations block (if any)
        const old = contentEl.querySelector(".rag-citations");
        if (old) old.remove();

        let groups = [];
        if (dedupe) {
          // Group by source
          const map = new Map();
          citations.forEach((c) => {
            const src = c.source || "";
            if (!map.has(src)) {
              map.set(src, { source: src, idxs: [] });
            }
            map.get(src).idxs.push(c.idx);
          });
          groups = Array.from(map.values()).sort((a, b) =>
            getBaseName(a.source).localeCompare(getBaseName(b.source))
          );
        } else {
          // Treat each citation as its own "group"
          groups = citations.map((c) => ({
            source: c.source || "",
            idxs: [c.idx],
          }));
        }

        // --- DOM creation ---
        const wrapper = document.createElement("div");
        wrapper.className = "rag-citations mt-2";
        const title = document.createElement("div");
        title.className = "rag-citations-title";
        title.textContent = "Sources";
        wrapper.appendChild(title);
        const list = document.createElement("div");
        list.className = "rag-citations-list";
        wrapper.appendChild(list);

        // --- Single loop for both cases, render and append items ---
        groups.forEach((group) => {
          const itemHTML = generateCitationItem(group);
          list.insertAdjacentHTML("beforeend", itemHTML);
        });

        contentEl.appendChild(wrapper);
      } catch (err) {
        console.warn("appendCitations failed:", err);
      }
    };

    // Ensure chatApp.enabledRagSources is initialized from chatApp.ragSources on app startup
    const loadEnabledSources = () => {
      const stored = localStorage.getItem("enabledRagSources");

      // Ensure ragSources exists as a Set for fallbacks
      if (
        !chatApp.ragSources ||
        (!(chatApp.ragSources instanceof Set) &&
          !Array.isArray(chatApp.ragSources))
      ) {
        chatApp.ragSources = new Set();
      }

      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          const cleaned = sanitizeArrayOfNames(parsed);
          chatApp.enabledRagSources = new Set(cleaned);
        } catch (e) {
          // fallback to enabling all known ragSources (empty by default)
          chatApp.enabledRagSources = new Set(
            Array.from(chatApp.ragSources || [])
          );
        }
      } else {
        // No saved preference -> default to enabling all current ragSources
        chatApp.enabledRagSources = new Set(
          Array.from(chatApp.ragSources || [])
        );
      }
    };

    // Save user selection persistently
    const saveEnabledSources = () => {
      try {
        const arr = sanitizeArrayOfNames(
          Array.from(chatApp.enabledRagSources || [])
        );
        localStorage.setItem("enabledRagSources", JSON.stringify(arr));
      } catch (e) {
        console.warn("saveEnabledSources failed:", e);
      }
    };

    // Forward declarations for circular dependencies
    let deleteEmbeddingsForSource;
    let renderEmbeddingSourcesUI;

    // Render the embedded sources as a checkbox list inside #embeddingSourcesList
    const createSourceCheckbox = (source, isChecked) => {
      const div = document.createElement("div");
      div.className = "form-check d-flex align-items-center";

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "form-check-input";
      checkbox.id = `source-checkbox-${source}`;
      checkbox.value = source;
      checkbox.checked = !!isChecked;

      addListener(checkbox, "change", (e) => {
        e.target.checked
          ? chatApp.enabledRagSources.add(source)
          : chatApp.enabledRagSources.delete(source);
        saveEnabledSources();
        updateDocStatus();
      });

      const label = document.createElement("label");
      label.className = "form-check-label flex-grow-1 ms-2";
      label.htmlFor = checkbox.id;
      label.textContent = source;

      // Delete button (trash icon)
      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.className = "btn btn-sm btn-outline-danger btn-delete-vector";
      deleteBtn.title = `Delete all vectors from source "${source}"`;
      deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';

      addListener(deleteBtn, "click", async () => {
        const ragSettingsModal = getOrCreateModal(chatApp.els.ragSettingsModal);
        try {
          // Hide the parent modal so confirm modal can show properly
          ragSettingsModal?.hide();

          if (
            !(await showConfirm(
              `Are you sure you want to delete all vectors from "${source}"?`,
              {
                title: "Delete Embeddings",
                okText: "Delete",
                cancelText: "Cancel"
              }
            ))
          ) {
            ragSettingsModal?.show();
            return;
          }

          const deletedCount = await deleteEmbeddingsForSource(source);
          showToast(
            `Deleted ${deletedCount} vectors for source "${source}" from DB.`
          );
        } catch (err) {
          console.error("Failed to delete vectors:", err);
          showToast(
            "Failed to delete vectors from the database. See console for details."
          );
        } finally {
          // Always restore the parent modal
          ragSettingsModal?.show();
        }
      });

      div.appendChild(checkbox);
      div.appendChild(label);
      div.appendChild(deleteBtn);
      return div;
    };

    // Async render that checks IndexedDB for embeddings first
    renderEmbeddingSourcesUI = async () => {
      const container = document.getElementById("embeddingSourcesList");
      if (!container) return;

      container.innerHTML = "";

      try {
        // Retrieve all embeddings from IndexedDB
        const allEmbeddings = await getAllEmbeddings();
        const wrapper = document.getElementById("embedding-sources-wrapper");

        // If no embeddings exist hide wrapper
        if (!allEmbeddings || allEmbeddings.length === 0) {
          wrapper?.classList.add("d-none");
          updateDocStatus();
          return;
        }

        wrapper?.classList.remove("d-none");

        // Build a set of sources that have embeddings
        const sourcesFromEmbeddings = new Set(
          allEmbeddings.map((e) => e.metadata?.source).filter(Boolean)
        );

        // Intersect with chatApp.ragSources so we only render known sources
        const sources = [...chatApp.ragSources].filter((s) =>
          sourcesFromEmbeddings.has(s)
        );

        sources.sort();

        sources.forEach((source) => {
          const isChecked = chatApp.enabledRagSources?.has(source);
          const checkboxDiv = createSourceCheckbox(source, isChecked);
          container.appendChild(checkboxDiv);
        });

        updateDocStatus();
      } catch (err) {
        console.error("Failed to read embeddings from IndexedDB:", err);
        showToast("Failed to check embeddings. See console for details.");
      }
    };

    const loadEmbeddingSourcesFromDB = async () => {
      // Get all embeddings from DB
      const allVectors = await getAllEmbeddings();
      if (!allVectors || allVectors.length === 0) {
        chatApp.ragSources = new Set();
        return;
      }

      // Extract unique sources
      const sourcesSet = new Set();
      allVectors.forEach((v) => {
        if (v.metadata?.source) {
          sourcesSet.add(v.metadata.source);
        }
      });

      chatApp.ragSources = sourcesSet;
    };


    // ---------------------------------------------------------------
    // 8. INDEXEDDB / STORAGE LAYER
    // ---------------------------------------------------------------

    // Open database/create object store as needed
    let _embedDb = null;

    const openEmbeddingDB = () => {
      return new Promise((resolve, reject) => {
        if (_embedDb) return resolve(_embedDb);
        const req = indexedDB.open(EMBED_DB_NAME, EMBED_DB_VERSION);

        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          let store;

          if (!db.objectStoreNames.contains(EMBED_STORE_NAME)) {
            store = db.createObjectStore(EMBED_STORE_NAME, { keyPath: "id" });
          } else {
            // Upgrade path: open the existing store to add missing indexes
            store = e.target.transaction.objectStore(EMBED_STORE_NAME);
          }

          // Create the index if it doesn't exist yet
          if (!store.indexNames.contains("bySource")) {
            store.createIndex("bySource", "metadata.source", { unique: false });
          }
        };

        req.onsuccess = (e) => {
          _embedDb = e.target.result;
          // Close this connection if another script changes the DB version
          _embedDb.onversionchange = () => {
            try { _embedDb.close(); } catch { }
            _embedDb = null;
          };
          resolve(_embedDb);
        };
        req.onerror = (e) => reject(e.target.error);
      });
    };

    // Save a list of vector objects
    const saveEmbeddingsToDB = async (vectors) => {
      const db = await openEmbeddingDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(EMBED_STORE_NAME, "readwrite");
        const store = tx.objectStore(EMBED_STORE_NAME);
        for (const v of vectors) store.put(v);
        tx.oncomplete = () => resolve();
        tx.onerror = (e) => reject(e.target.error);
      });
    };

    // Fetch all or by filter
    const getAllEmbeddings = async (filter = {}) => {
      const db = await openEmbeddingDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(EMBED_STORE_NAME, "readonly");
        const store = tx.objectStore(EMBED_STORE_NAME);
        const req = store.getAll();
        req.onsuccess = () => {
          let result = req.result;
          if (filter.source) {
            result = result.filter((v) => v.metadata?.source === filter.source);
          }
          resolve(result);
        };
        req.onerror = (e) => reject(e.target.error);
      });
    };

    // Clear all embeddings
    const clearAllEmbeddings = async () => {
      // Clear the object store and return number cleared
      const db = await openEmbeddingDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(EMBED_STORE_NAME, "readwrite");
        const store = tx.objectStore(EMBED_STORE_NAME);

        // First count then clear so we know how many were removed
        const countReq = store.count();
        countReq.onsuccess = () => {
          const count = countReq.result || 0;
          if (!count) {
            resolve(0);
            return;
          }
          const clearReq = store.clear();
          clearReq.onsuccess = () => resolve(count);
          clearReq.onerror = (e) => reject(e.target.error);
        };
        countReq.onerror = (e) => reject(e.target.error);
      });
    };

    // Delete embeddings for a specific source
    // With an index named "by_source"
    deleteEmbeddingsForSource = async (sourceName) => {
      const db = await openEmbeddingDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(EMBED_STORE_NAME, "readwrite");
        const store = tx.objectStore(EMBED_STORE_NAME);
        const idx = store.index("bySource");

        let deleted = 0;
        const cursorReq = idx.openKeyCursor(IDBKeyRange.only(sourceName));

        cursorReq.onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            store.delete(cursor.primaryKey);
            deleted += 1;
            cursor.continue();
          } else {
            tx.oncomplete = () => {
              // Sync in-memory state and UI as you already do
              chatApp.ragSources?.delete(sourceName);
              chatApp.enabledRagSources?.delete(sourceName);
              saveEnabledSources();
              try { renderEmbeddingSourcesUI(); } catch { }
              try { updateDocStatus(); } catch { }
              resolve(deleted);
            };
            tx.onerror = (ev) => reject(ev.target.error);
          }
        };
        cursorReq.onerror = (e) => reject(e.target.error);
      });
    };

    const getEmbeddingsCount = async () => {
      const db = await openEmbeddingDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(EMBED_STORE_NAME, "readonly");
        const store = tx.objectStore(EMBED_STORE_NAME);
        const req = store.count();
        req.onsuccess = () => resolve(req.result || 0);
        req.onerror = (e) => reject(e.target.error);
      });
    };

    // Clear all embeddings
    const clearEmbeddings = async () => {
      try {
        const cleared = await clearAllEmbeddings();
        chatApp.ragSources = new Set();
        chatApp.enabledRagSources = new Set(); // Clear enabled sources too
        await saveEnabledSources(); // Persist the empty set
        await renderEmbeddingSourcesUI(); // Update UI to show no sources
        updateStatus("All embeddings cleared");
        updateDocStatus();

        setTimeout(() => {
          updateStatus("Ready");
        }, 3500);

        return cleared;
      } catch (err) {
        console.error("Error clearing embeddings:", err);
        throw err;
      }
    };

    // ---------------------------------------------------------------
    // 9. EMBEDDING & RAG OPERATIONS
    // ---------------------------------------------------------------

    // Get OpenAI embeddings for a batch
    const getEmbeddingsBatchOpenAI = async (apiKey, texts) => {
      const res = await fetch("https://api.openai.com/v1/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ model, input: texts }),
      });
      if (!res.ok) {
        const bodyText = await res.text().catch(() => "<no body>");
        console.error(
          "[getEmbeddingsBatchOpenAI] HTTP error",
          res.status,
          bodyText
        );
        throw new Error(bodyText || `HTTP ${res.status}`);
      }
      const data = await res.json();
      if (!data || !Array.isArray(data.data)) {
        console.error(
          "[getEmbeddingsBatchOpenAI] unexpected response body:",
          data
        );
        throw new Error("Unexpected embeddings response");
      }
      return data.data.map((d) => d.embedding);
    };

    // Converts text string to embedding chunks and saves to IndexedDB.
    const embedAndStoreTextChunks = async ({
      text,
      sourceName = "docContext",
      showLog = (msg) => { },
      getApiKey,
    }) => {
      const apiKey = getApiKey();
      if (!apiKey) throw new Error("API key not configured for embeddings.");

      if (!text || !text.trim()) {
        throw new Error(`No text content to embed from ${sourceName}`);
      }

      showLog("Chunking for embedding...");

      const maxTokens = chatApp?.rag?.chunkingTokens ?? 800;
      const overlap = chatApp?.rag?.overlapTokens ?? 48;
      const chunksMeta = chunkTextByTokens(text, maxTokens, overlap);

      console.log(
        `[embedAndStore] ${sourceName}: textLen=${String(text || "").length}, chunks=${chunksMeta.length}`
      );

      showLog(`Total chunks: ${chunksMeta.length}`);
      if (!chunksMeta?.length) {
        throw new Error(
          "No chunks generated for embedding (text may be empty after sanitization)."
        );
      }

      // Precompute batches with their starting indices
      const batches = Array.from(
        { length: Math.ceil(chunksMeta.length / batchSize) },
        (_, k) => ({
          start: k * batchSize,
          items: chunksMeta.slice(k * batchSize, k * batchSize + batchSize),
        })
      );

      const outputs = [];
      for (const { start, items } of batches) {
        const texts = items.map((x) => x.text);
        showLog(
          `Requesting embeddings for batch ${start / batchSize + 1} (${texts.length} items)...`
        );

        const embeddings = await getEmbeddingsBatchOpenAI(apiKey, texts);

        outputs.push(
          ...items.map((chunk, j) => {
            const idx = start + j;
            return {
              id: `${sourceName}::${idx}`,
              embedding: embeddings[j],
              text: chunk.text,
              tokens: chunk.tokens,
              metadata: {
                source: sourceName,
                chunkIndex: idx,
                totalChunks: chunksMeta.length,
                model,
                createdAt: new Date().toISOString(),
              },
            };
          })
        );
      }

      await saveEmbeddingsToDB(outputs);
      showLog("Embeddings saved.");
      return outputs;
    };

    // token-budget
    const getRagContextForPrompt = async (
      userPrompt,
      {
        topK = 12,
        minSim = 0.25,
        budgetTokens = 6000, // total token budget for all snippets
        minSnippetTokens = 250, // ensure each snippet has some substance
        sources = null, // array of filenames to filter, or null for all
      } = {}
    ) => {
      // If caller explicitly passed an empty array, treat as "RAG disabled"
      if (Array.isArray(sources) && sources.length === 0) {
        // explicit user choice: no RAG sources selected -> skip retrieval
        return { context: "", citations: [] };
      }
      // Retrieve vectors (optionally by source) BEFORE querying embeddings
      let vectors = await getAllEmbeddings({});
      if (sources?.length) {
        const allow = new Set(sources);
        vectors = vectors.filter(
          (v) => v.metadata && allow.has(v.metadata.source)
        );
      }
      if (!vectors || !vectors.length) {
        return { context: "", citations: [] };
      }

      const apiKey = getApiKey();
      const [queryEmbedding] = await getEmbeddingsBatchOpenAI(apiKey, [
        userPrompt,
      ]);

      const scored = vectors
        .map((v) => ({
          ...v,
          similarity: cosineSim(queryEmbedding, v.embedding),
        }))
        .sort((a, b) => b.similarity - a.similarity)
        .filter((v) => v.similarity >= minSim)
        .slice(0, topK);

      const blocks = [];
      let usedTok = 0;

      for (let i = 0; i < scored.length; i++) {
        const s = scored[i];
        const remaining = Math.max(0, budgetTokens - usedTok);
        if (remaining <= 0) break;

        const wantTokens = Math.max(minSnippetTokens, remaining);
        const snippet = sliceByTokenEstimate(s.text.trim(), wantTokens);
        if (!snippet) continue;

        blocks.push(
          `[${i + 1}] (source: ${s.metadata.source}, chunk: ${s.metadata.chunkIndex
          }, score: ${s.similarity.toFixed(3)})\n` + snippet
        );

        usedTok += estimateTokens(snippet);
      }

      return {
        context: blocks.join("\n\n-----\n\n"),
        citations: scored.map((s, i) => ({
          idx: i + 1,
          source: s.metadata.source,
          chunkIndex: s.metadata.chunkIndex,
          similarity: s.similarity,
        })),
      };
    };

    // Wrapper: simple, safe entry point for UI code
    const getRagContext = async (userPrompt, options = {}) => {
      try {
        return await getRagContextForPrompt(userPrompt, options);
      } catch (e) {
        console.warn("RAG retrieval failed, continuing without embeddings:", e);
        return { context: "", citations: [] };
      }
    };

    // ---------------------------------------------------------------
    // 10. RAG SETTINGS & PERSISTENCE
    // ---------------------------------------------------------------

    // Persistence helpers (per-model overrides)
    const getRagOverridesStorageKey = () => {
      return "chatApp.ragOverrides";
    };

    const loadAllRagOverrides = () => {
      try {
        const raw = localStorage.getItem(getRagOverridesStorageKey());
        return raw ? JSON.parse(raw) : {};
      } catch (err) {
        console.warn("Failed to load RAG overrides:", err);
        return {};
      }
    };

    const saveAllRagOverrides = (obj) => {
      try {
        localStorage.setItem(getRagOverridesStorageKey(), JSON.stringify(obj));
      } catch (err) {
        console.warn("Failed to save RAG overrides:", err);
      }
    };

    const saveRagOverridesForModel = (modelId, ragObj) => {
      if (!modelId) return;
      const all = loadAllRagOverrides();
      all[modelId] = { ...ragObj }; // shallow copy
      saveAllRagOverrides(all);
    };

    const loadRagOverridesForModel = (modelId) => {
      if (!modelId) return null;
      const all = loadAllRagOverrides();
      return all[modelId] || null;
    };

    // init/merge with preset
    const initRagFromModel = () => {
      const cfg = getActiveModelConfig();
      const preset = chatApp.ragPresets[cfg.id] || chatApp.ragPresets.default;
      // start with preset
      const base = { ...preset };
      // merge any saved user overrides for this model (overrides win)
      const saved = loadRagOverridesForModel(cfg.id);
      if (saved && typeof saved === "object") Object.assign(base, saved);

      chatApp.rag = base;

      // quick validation to keep values sane
      if (chatApp.rag.chunkingTokens < chatApp.rag.minSnippetTokens) {
        chatApp.rag.chunkingTokens = chatApp.rag.minSnippetTokens;
      }
      if (chatApp.rag.overlapTokens >= chatApp.rag.chunkingTokens) {
        chatApp.rag.overlapTokens = Math.max(0, chatApp.rag.chunkingTokens - 1);
      }
    };

    // Populate UI from current state (unchanged style)
    const populateRagFormFromState = () => {
      const { els } = chatApp;
      const r = chatApp.rag || chatApp.ragPresets.default;
      els.ragBudgetTokens.value = r.budgetTokens;
      els.ragMinSnippetTokens.value = r.minSnippetTokens;
      els.ragTopK.value = r.topK;
      els.ragMinSim.value = r.minSim;
      els.ragChunkTokens.value =
        r.chunkingTokens ?? chatApp.ragPresets.default.chunkingTokens;
      els.ragOverlapTokens.value =
        r.overlapTokens ?? chatApp.ragPresets.default.overlapTokens;
    };

    // Read UI -> state, validate/clamp, persist per-model
    const readRagFormIntoState = () => {
      const r = (chatApp.rag = chatApp.rag || {});
      // basic fields
      r.budgetTokens = clampInt(
        chatApp.els.ragBudgetTokens.value,
        1000,
        20000,
        r.budgetTokens ?? chatApp.ragPresets.default.budgetTokens
      );
      r.minSnippetTokens = clampInt(
        chatApp.els.ragMinSnippetTokens.value,
        50,
        1000,
        r.minSnippetTokens ?? chatApp.ragPresets.default.minSnippetTokens
      );
      r.topK = clampInt(
        chatApp.els.ragTopK.value,
        1,
        32,
        r.topK ?? chatApp.ragPresets.default.topK
      );
      r.minSim = clampNum(
        chatApp.els.ragMinSim.value,
        0,
        1,
        r.minSim ?? chatApp.ragPresets.default.minSim
      );

      // chunking fields
      r.chunkingTokens = clampInt(
        chatApp.els.ragChunkTokens.value,
        50, // conservative floor; will be checked against minSnippetTokens below
        16384, // reasonable ceiling
        r.chunkingTokens ?? chatApp.ragPresets.default.chunkingTokens
      );
      r.overlapTokens = clampInt(
        chatApp.els.ragOverlapTokens.value,
        0,
        8192,
        r.overlapTokens ?? chatApp.ragPresets.default.overlapTokens
      );

      // Enforce chunkingTokens >= minSnippetTokens
      if (r.chunkingTokens < r.minSnippetTokens) {
        console.warn(
          `chunkingTokens (${r.chunkingTokens}) < minSnippetTokens (${r.minSnippetTokens}) - clamping chunkingTokens up to minSnippetTokens`
        );
        r.chunkingTokens = r.minSnippetTokens;
        chatApp.els.ragChunkTokens.value = r.chunkingTokens;
      }

      // Enforce overlap < chunkingTokens
      if (r.overlapTokens >= r.chunkingTokens) {
        const clamped = Math.max(0, r.chunkingTokens - 1);
        console.warn(
          `overlapTokens (${r.overlapTokens}) >= chunkingTokens (${r.chunkingTokens}) - clamping overlapTokens to ${clamped}`
        );
        r.overlapTokens = clamped;
        chatApp.els.ragOverlapTokens.value = r.overlapTokens;
      }

      // Persist overrides for current model
      const modelId =
        (getActiveModelConfig && getActiveModelConfig().id) ||
        chatApp.currentModelKey;
      saveRagOverridesForModel(modelId, r);

      console.log("RAG form read into state:", r);
      return r;
    };

    // ---------------------------------------------------------------
    // 11. SCROLL & VISIBILITY MANAGEMENT
    // ---------------------------------------------------------------

    // Auto-follow the target element until the user interacts.
    // Pauses on user input; resumes when scrolled back to bottom (configurable).
    const ensureVisible = (
      el,
      {
        marginTop = 20,
        bottomThreshold = 2,        // px from bottom counts as "at bottom"
        resumeOnBottom = true,      // re-enable follow when user scrolls to bottom
        startFollowing = true,      // start in follow mode
        smooth = true,
        alignTopOnStart = true,
        rafAlignTries = 2,          // extra passes to catch late layout
        instantOnStart = true,      // snap synchronously when created/called
        keepProgrammaticFor = 80,   // ms to keep programmatic flag for snap
      } = {}
    ) => {
      const container = document.getElementById("chatContainer");
      if (!el || !container) return;

      let following = startFollowing;
      let programmaticScroll = false;
      let programmaticTimer = null;
      let alignedOnce = !alignTopOnStart; // if alignTopOnStart, we haven't aligned yet
      let smoothScrolling = smooth;

      const clearProgrammaticFlagSoon = (ms = 400) => {
        if (programmaticTimer) clearTimeout(programmaticTimer);
        programmaticTimer = setTimeout(() => {
          programmaticScroll = false;
          programmaticTimer = null;
        }, ms);
      };

      const atBottom = () =>
        container.scrollHeight - container.clientHeight - container.scrollTop <= bottomThreshold;

      const calcTargetTop = () => {
        // Guard against not yet in DOM
        if (!el.isConnected) return container.scrollTop;

        const elRect = el.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        let targetTop = elRect.top - containerRect.top + container.scrollTop - marginTop;

        // Clamp to valid scroll range
        const maxTop = Math.max(0, container.scrollHeight - container.clientHeight);
        if (!Number.isFinite(targetTop)) targetTop = 0;
        targetTop = Math.max(0, Math.min(targetTop, maxTop));
        return targetTop;
      };

      const performScroll = (to, { snap = false } = {}) => {
        programmaticScroll = true;

        if (snap) {
          // Force instant snap even if CSS has scroll-behavior: smooth
          const prevBehavior = container.style.scrollBehavior;
          container.style.scrollBehavior = "auto";
          container.scrollTop = to;
          // Restore style and keep the programmatic flag long enough to ignore scroll events
          setTimeout(() => {
            container.style.scrollBehavior = prevBehavior;
            programmaticScroll = false;
          }, keepProgrammaticFor);
        } else {
          container.scrollTo({
            top: to,
            behavior: smoothScrolling ? "smooth" : "auto",
          });
          clearProgrammaticFlagSoon(smoothScrolling ? 500 : 50);
        }
      };

      const scrollIntoViewIfNeeded = (forceTop = false) => {
        if (!following) return;

        const elRect = el.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        const offsetTop = elRect.top - containerRect.top + container.scrollTop;
        const targetTop = Math.max(0, offsetTop - marginTop);

        const fullyVisible =
          elRect.top >= containerRect.top + marginTop &&
          elRect.bottom <= containerRect.bottom;

        const nearTop = Math.abs(container.scrollTop - targetTop) <= 1;

        if (forceTop || !fullyVisible || (!alignedOnce && !nearTop)) {
          performScroll(targetTop);
          alignedOnce = true;
        }
      };

      // Intersection: when visibility changes, keep it in view (if following)
      const io = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.intersectionRatio < 1) {
              scrollIntoViewIfNeeded();
            }
          });
        },
        {
          root: container,
          threshold: [0, 1],
          rootMargin: `-${marginTop}px 0px 0px 0px`,
        }
      );
      io.observe(el);

      // Resize: element grows (e.g., streaming), keep it visible (if following)
      const ro = new ResizeObserver(() => {
        scrollIntoViewIfNeeded();
      });
      ro.observe(el);

      // User interaction should pause following
      const pauseFollowing = () => {
        if (!programmaticScroll) {
          following = false;
        }
      };

      const onWheel = () => pauseFollowing();
      const onTouchStart = () => pauseFollowing();
      const onPointerDown = () => pauseFollowing();
      const onMouseDown = () => pauseFollowing();

      // Keys that typically scroll
      const scrollKeys = new Set([
        "PageDown",
        "PageUp",
        "ArrowDown",
        "ArrowUp",
        "ArrowLeft",
        "ArrowRight",
        "Home",
        "End",
        " ",
      ]);
      const onKeyDown = (e) => {
        if (scrollKeys.has(e.key)) pauseFollowing();
      };

      // On any scroll: if user scrolled away from bottom, pause;
      // if they scroll back to bottom and allowed, resume.
      const onScroll = () => {
        if (programmaticScroll) return;
        if (atBottom()) {
          if (resumeOnBottom) following = true;
        } else {
          following = false;
        }
      };

      addListener(container, "wheel", onWheel, { passive: true });
      addListener(container, "touchstart", onTouchStart, { passive: true });
      addListener(container, "pointerdown", onPointerDown, { passive: true });
      addListener(container, "mousedown", onMouseDown, { passive: true });
      addListener(container, "scroll", onScroll, { passive: true });
      addListener(window, "keydown", onKeyDown, { capture: true });

      // Initial alignment: SNAP immediately, then do a couple rAF passes to correct.
      if (following) {
        if (instantOnStart && alignTopOnStart) {
          alignedOnce = true;
          performScroll(calcTargetTop(), { snap: true }); // instant
        }

        const tries = Math.max(0, rafAlignTries);
        let count = 0;

        const adjust = () => {
          // Allow smooth or auto (per option) for refinement passes
          scrollIntoViewIfNeeded(true);
          if (++count < tries) requestAnimationFrame(adjust);
        };

        if (tries > 0) requestAnimationFrame(adjust);
      }

      return {
        pause() {
          following = false;
        },
        resume() {
          following = true;
          scrollIntoViewIfNeeded(true);
        },
        // force an immediate top alignment on demand (e.g., on send)
        snap() {
          following = true;
          alignedOnce = true;
          performScroll(calcTargetTop(), { snap: true });
        },
        isFollowing() {
          return following;
        },
        disconnect() {
          io.disconnect();
          ro.disconnect();
          container.removeEventListener("wheel", onWheel);
          container.removeEventListener("touchstart", onTouchStart);
          container.removeEventListener("pointerdown", onPointerDown);
          container.removeEventListener("mousedown", onMouseDown);
          container.removeEventListener("scroll", onScroll);
          window.removeEventListener("keydown", onKeyDown, { capture: true });
          if (programmaticTimer) clearTimeout(programmaticTimer);
        },
      };
    };

    // ---------------------------------------------------------------
    // 12. BUTTON STATE MANAGEMENT
    // ---------------------------------------------------------------

    const setSendButtonToStop = () => {
      const btn = chatApp.els.sendBtn;
      if (!btn) return;
      btn.innerHTML = stopSVG;
      btn.classList.add("btn-danger");
      btn.title = "Stop (abort current response)";
    };

    const restoreSendButton = () => {
      const btn = chatApp.els.sendBtn;
      if (!btn) return;
      btn.innerHTML = originalSendBtnHTML;
      btn.classList.remove("btn-danger");
      btn.title = "";
    };

    // ---------------------------------------------------------------
    // 13. MARKDOWN & RENDERING
    // ---------------------------------------------------------------

    // Turn an info string, class, or filename into a Prism language key.
    const normalizeLanguage = (info = "") => {
      const raw = info == null ? "" : String(info).trim();
      if (!raw) return "none";

      // First token up to whitespace
      let first = raw.split(/\s+/)[0];

      // Strip common prefixes (case-insensitive): language- or lang-
      first = first.replace(/^(?:language|lang)-/i, "");

      // If it's a path (e.g., "src/app.tsx"), keep only the filename segment
      if (first.includes("/")) first = first.split("/").pop();

      // Keep only the leading language-ish token (drop glued attrs like {1,3} or :line-numbers)
      const m = first.match(/^[A-Za-z0-9#+._-]+/);
      const token = (m ? m[0] : "").trim();
      if (!token) return "none";

      const tokenLower = token.toLowerCase();

      // Dotfiles like ".env"
      if (token.startsWith(".") && token.length > 1) {
        if (FILENAME_TO_LANG[token] || FILENAME_TO_LANG[tokenLower]) {
          return FILENAME_TO_LANG[token] || FILENAME_TO_LANG[tokenLower];
        }
        // Drop leading dot for potential extension inference below
      }

      // Aliases (by language name)
      if (LANG_ALIASES[tokenLower]) return LANG_ALIASES[tokenLower];

      // Exact filename matches (case-insensitive)
      if (FILENAME_TO_LANG[token] || FILENAME_TO_LANG[tokenLower]) {
        return FILENAME_TO_LANG[token] || FILENAME_TO_LANG[tokenLower];
      }

      // Extension inference for filenames like "app.tsx" or "Package.JSON"
      const ext = (token.match(/\.([A-Za-z0-9]+)$/) || [])[1];
      if (ext && FILE_EXT_TO_LANG[ext.toLowerCase()]) {
        return FILE_EXT_TO_LANG[ext.toLowerCase()];
      }

      // Treat plain text synonyms
      if (tokenLower === "plain" || tokenLower === "text" || tokenLower === "plaintext" || tokenLower === "none") {
        return "none";
      }

      // Fallback: return normalized token as-is
      return tokenLower;
    };

    const fixNestedMarkdownFences = (md) => {
      if (!md) return "";

      const lines = md.split(/\r?\n/);
      const out = [];
      let i = 0;

      // Matches a fence line. We only open on markdown|md.
      const openMdFenceRe = /^([ \t]*)(`{3,})(markdown|md)[ \t]*$/i;

      while (i < lines.length) {
        const open = lines[i].match(openMdFenceRe);
        if (!open) {
          out.push(lines[i++]);
          continue;
        }

        const indent = open[1] || "";
        const openFence = open[2]; // e.g., "```"
        const openFenceLen = openFence.length;
        const lang = open[3];

        // Regexes that consider fences of length >= openFenceLen
        const fenceNoLangRe = new RegExp(
          `^[ \\t]*\`{${openFenceLen},}[ \\t]*$`
        );
        const fenceWithLangRe = new RegExp(
          `^[ \\t]*\`{${openFenceLen},}[ \\t]*([^\\s\`][^\\r\\n]*)$`,
          "i"
        );

        // Find the true matching close by balancing inner openers/closers
        let j = i + 1;
        let depth = 1;

        for (; j < lines.length; j++) {
          const line = lines[j];

          if (fenceWithLangRe.test(line)) {
            // line like ```bash or ````python counts as a nested opener
            depth++;
          } else if (fenceNoLangRe.test(line)) {
            // bare ``` (or longer) counts as a closer
            depth--;
            if (depth === 0) break;
          }
        }

        // If no proper closing fence found, keep the original line and continue
        if (j >= lines.length) {
          out.push(lines[i++]);
          continue;
        }

        // Content between open and close
        const content = lines.slice(i + 1, j);

        // Determine the longest backtick run at line start inside the content
        let longestRun = 0;
        for (const l of content) {
          const m = l.match(/^[ \t]*(`{3,})/);
          if (m) longestRun = Math.max(longestRun, m[1].length);
        }

        // New fence length: one more than any run we saw, and > opening length
        const newLen = Math.max(openFenceLen + 1, longestRun + 1);
        const newFence = "`".repeat(newLen);

        // Replace the block with upgraded fences
        out.push(`${indent}${newFence}${lang}`);
        out.push(...content);
        out.push(`${indent}${newFence}`);

        // Advance past the closing fence
        i = j + 1;
      }

      return out.join("\n");
    };

    // Marked.js setup: custom renderer
    const renderer = {
      code(code, infostring, escaped) {
        // Handle token objects from marked.js
        let actualCode = "";
        let actualLang = "";

        if (code && typeof code === "object") {
          // Extract from token object
          actualCode = code.text || "";
          actualLang = code.lang || infostring || "";
        } else {
          // Fallback to string format
          actualCode = String(code || "");
          actualLang = String(infostring || "");
        }

        const lang = normalizeLanguage(actualLang);
        return `<pre><code class="language-${lang}" data-language="${lang}">${escapeHtml(
          actualCode
        )}</code></pre>`;
      },

      html(htmlToken) {
        // Accept both string and token objects from marked
        let htmlStr = "";
        if (htmlToken && typeof htmlToken === "object") {
          // For 'html' tokens, marked provides .text and/or .raw
          htmlStr = htmlToken.text || htmlToken.raw || "";
        } else {
          htmlStr = String(htmlToken || "");
        }

        // Escape HTML to avoid injection
        return escapeHtml(htmlStr);
      },

      // Safer link renderer
      link(href, title, text) {
        const actualHref =
          typeof href === "object"
            ? href.href || href.raw || ""
            : String(href || "");
        const actualText =
          typeof href === "object"
            ? href.text || href.raw || actualHref
            : String(text || href || "Link");
        const actualTitle =
          typeof title === "object"
            ? title.title || title.text || ""
            : String(title || "");

        const safe = isSafeHref(actualHref);
        const safeHref = safe ? actualHref : "#";
        const t = actualTitle ? ` title="${escapeHtml(actualTitle)}"` : "";

        return `<a href="${escapeHtml(
          safeHref
        )}"${t} target="_blank" rel="noopener noreferrer nofollow ugc">${escapeHtml(
          actualText
        )}</a>`;
      },
    };

    // Ensure marked is configured before parsing
    const ensureMarkedConfig = () => {
      if (typeof marked === "undefined" || chatApp.markedConfigured) return;

      marked.setOptions({
        gfm: true,
        breaks: true,
        headerIds: false,
        mangle: false,
        pedantic: false,
      });
      marked.use({ renderer }); // your custom renderer
      chatApp.markedConfigured = true;
    };

    // Process with Marked.js
    const markdownToHtml = (md) => {
      if (!md) return "";
      md = String(md).replace(/\r\n?/g, "\n");

      if (typeof marked === "undefined") return escapeHtml(md);
      ensureMarkedConfig();
      
      // Parse the corrected Markdown string.
      return marked.parse(md);
    };

    // ---------------------------------------------------------------
    // 14. MESSAGE DISPLAY & ENHANCEMENT
    // ---------------------------------------------------------------

    // --- Typing dots helpers ---
    const createTypingDots = () => {
      const d = document.createElement("div");
      d.className = "typing-dots";
      d.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
      return d;
    };

    const showTypingDots = (bubbleEl) => {
      if (!bubbleEl) return;
      const contentEl = bubbleEl.querySelector(".message-content");
      if (!contentEl) return;
      if (!contentEl.querySelector(".typing-dots")) {
        contentEl.appendChild(createTypingDots());
      }
    };

    const hideTypingDots = (bubbleEl) => {
      bubbleEl?.querySelector(".typing-dots")?.remove();
    };

    // Called once when the FIRST token arrives.
    // Replaces dots with shimmer and keeps normal streaming visuals.
    const startStreamingVisuals = (contentEl) => {
      if (!contentEl) return;
      const bubble = contentEl.closest(".message-bubble");
      if (!bubble) return;

      // Remove typing dots
      hideTypingDots(bubble);

      // Enable shimmer overlay (now that we have real content)
      bubble.classList.add("streaming");
      let shimmer = bubble.querySelector(".typing-shimmer");
      if (!shimmer) {
        shimmer = document.createElement("div");
        shimmer.className = "typing-shimmer";
        bubble.insertBefore(shimmer, contentEl);
      }
    };

    // Display Message
    const displayMessage = (text, sender, state = "normal") => {
      const chatContainer = chatApp.els.chatContainer;
      if (!chatContainer) return null;

      const isUser = sender === "user";
      const timestamp = new Date();

      const wrapper = document.createElement("div");
      wrapper.className =
        `d-flex align-items-start gap-3 mb-4 message-fade-in` +
        (isUser ? " flex-row-reverse" : "");
      wrapper.dataset.role = isUser ? "user" : "assistant";

      const avatar = document.createElement("div");
      avatar.className =
        `chat-avatar flex-shrink-0` + (isUser ? " bg-secondary" : "");
      avatar.innerHTML = isUser ? userSVG : robotSVG;

      const bubble = document.createElement("div");

      // Add .streaming if state is 'streaming'
      const classes = [
        "message-bubble",
        isUser ? "user-message" : "bot-message",
        isUser ? "p-3" : "px-3 py-4",
        "rounded",
        !isUser && state === "streaming" ? "streaming" : null,
      ]
        .filter(Boolean)
        .join(" ");

      bubble.className = classes;
      const content = document.createElement("div");
      content.className = "message-content small";

      if (isUser) {
        content.innerHTML = escapeHtml(text || "");
      } else if (text) {
        content.innerHTML = markdownToHtml(text);
      } else if (state === "streaming") {
        // Show typing dots first (no shimmer yet)
        content.appendChild(createTypingDots());
      }

      bubble.appendChild(content);

      let timestampEl = null;
      if (!isUser) {
        timestampEl = document.createElement("div");
        timestampEl.className = "message-timestamp";
        timestampEl.textContent = formatTimestamp(timestamp);
        bubble.appendChild(timestampEl);
      }

      wrapper.appendChild(avatar);
      wrapper.appendChild(bubble);
      chatContainer.appendChild(wrapper);

      // Small helpers for streaming/finalization
      const setText = (newText) => {
        content.innerHTML = isUser
          ? escapeHtml(newText)
          : markdownToHtml(newText);
      };
      const setStreaming = (on) => {
        if (isUser) return;
        bubble.classList.toggle("streaming", !!on);
        let shimmer = bubble.querySelector(".typing-shimmer");
        if (on && !shimmer) {
          shimmer = document.createElement("div");
          shimmer.className = "typing-shimmer";
          bubble.insertBefore(shimmer, content);
        } else if (!on && shimmer) {
          shimmer.remove();
        }
      };
      const setTimestamp = (date = new Date()) => {
        if (timestampEl) timestampEl.textContent = formatTimestamp(date);
      };

      return { wrapper, bubble, content, setText, setStreaming, setTimestamp };
    };

    // Copy Code
    const copyCode = async (btn, text) => {
      try {
        await navigator.clipboard.writeText(text);
        btn.innerHTML = `${checkSVG}`;
        setTimeout(() => {
          btn.innerHTML = `${copySVG}`;
        }, 2000);
      } catch (err) {
        console.error("Failed to copy code:", err);
        showToast("Failed to copy code. Please try again or copy manually.", {
          type: "danger",
        });
      }
    };

    // ---- Intelligent highlighting with language loading ----
    const intelligentHighlight = async (container) => {
      const Prism = window.Prism;
      if (!Prism) return;

      const hasAutoloader = !!Prism.plugins?.autoloader;

      if (!hasAutoloader) {
        // Collect needed languages from class names and data attributes
        const needed = new Set();
        container.querySelectorAll("pre code").forEach((el) => {
          // class="language-xxx"
          const langClass = Array.from(el.classList).find((c) => c.startsWith("language-"));
          const raw = langClass ? langClass.replace("language-", "") : (el.getAttribute("data-language") || "");
          const lang = normalizeName(raw);

          if (lang && !SKIP_LANGUAGES.has(lang)) {
            needed.add(lang);
            if (!el.classList.contains(`language-${lang}`)) {
              if (Prism.util?.setLanguage) Prism.util.setLanguage(el, lang);
              else el.classList.add(`language-${lang}`);
            }
          }
        });

        // Load each language including its dependencies (sequential to preserve order)
        for (const lang of needed) {
          try {
            await loadLanguageWithDeps(lang);
          } catch (e) {
            console.warn(`Failed to load language ${lang}:`, e.message);
          }
        }
      }

      // Highlight
      try {
        Prism.highlightAllUnder(container);
      } catch (e) {
        console.warn("highlightAllUnder failed:", e.message);
        // Fallback to element-by-element to avoid a single failure breaking all
        try {
          manualHighlightAll(container);
        } catch (e2) {
          console.warn("Manual highlight failed:", e2.message);
        }
      }
    };

    // Enhance Content with copy button, format for and highlight with Prism.js
    const enhanceContent = (container) => {
      container.querySelectorAll("pre > code").forEach((codeEl) => {
        const pre = codeEl.parentElement;

        if (pre.parentElement.classList.contains("code-block-wrapper")) return;

        const wrapper = document.createElement("div");
        wrapper.className = "code-block-wrapper";

        const header = document.createElement("div");
        header.className =
          "pre-header d-flex justify-content-between align-items-center";

        // Find language from code or pre
        let langName = "";
        [...pre.classList, ...codeEl.classList].forEach((cls) => {
          if (cls.startsWith("language-")) langName = cls.substring(9);
        });

        const langLabel = document.createElement("span");
        langLabel.className = "code-lang-label small";
        langLabel.textContent = langName || "code";

        const btn = document.createElement("button");
        btn.className = "btn btn-sm btn-outline-secondary copy-btn";
        btn.innerHTML = `${copySVG}`;
        addListener(btn, "click", () => copyCode(btn, codeEl.textContent));

        header.appendChild(langLabel);
        header.appendChild(btn);

        pre.parentNode.replaceChild(wrapper, pre);
        wrapper.appendChild(header);
        wrapper.appendChild(pre);
      });
      // Highlight once at the end
      intelligentHighlight(container);
    };

    // Finalize
    const finalizeContent = (contentEl, fullResponse) => {
      //console.log("=== Full Markdown Before Rendering ===\n\n", fullResponse);
      const fixedMd = fixNestedMarkdownFences(fullResponse);
      //console.log("=== Corrected MD Before Rendering ===\n\n", fixedMd);
      const html = markdownToHtml(fixedMd);
      //console.log("=== Marked.js HTML Response ===\n\n", html);
      contentEl.innerHTML = html;
      enhanceContent(contentEl);
    };

    // ---------------------------------------------------------------
    // 15. MESSAGE HISTORY MANAGEMENT
    // ---------------------------------------------------------------

    // Prune History from context
    const getMaxTurns = () =>
      Number.isFinite(+chatApp?.maxHistory) ? +chatApp.maxHistory : 12;

    const pruneHistory = () => {
      //console.log("Message history:", chatApp.messageHistory);
      const maxTurns = getMaxTurns();
      const systems = (chatApp.messageHistory || []).filter((m) => m.role === "system");
      const convo = (chatApp.messageHistory || []).filter((m) => m.role !== "system");
      // keep last N turns (N user + N assistant)
      const kept = convo.slice(-maxTurns * 2);
      chatApp.messageHistory = [
        systems[0], ...kept,
      ];
      //console.log("Message history after prune:", chatApp.messageHistory);
    };

    const findLastAssistantIndex = (arr = chatApp.messageHistory) => {
      if (!Array.isArray(arr)) return -1;
      for (let i = arr.length - 1; i >= 0; i--) {
        if (arr[i].role === "assistant") return i;
      }
      return -1;
    };

    const stripLastAssistant = (messages) => {
      const idx = findLastAssistantIndex(messages);
      if (idx === -1) return messages;
      return messages.slice(0, idx).concat(messages.slice(idx + 1));
    };

    const updateMessageHistory = (content, { isRetry = false } = {}) => {
      const idx = isRetry ? findLastAssistantIndex(chatApp.messageHistory) : -1;

      if (isRetry && idx !== -1) {
        chatApp.messageHistory[idx] = {
          ...chatApp.messageHistory[idx],
          content,
        };
      } else {
        chatApp.messageHistory.push({ role: "assistant", content });
      }

      // Optional continuous pruning
      pruneHistory();

      if (typeof updateMessageCount === "function") updateMessageCount();
    };

    const getLastUserPrompt = () => {
      const m = [...chatApp.messageHistory]
        .reverse()
        .find((m) => m.role === "user" && m.content && m.content.trim());
      return m ? m.content : "";
    };

    // ---------------------------------------------------------------
    // 16. DOCUMENT CONTEXT MANAGEMENT
    // ---------------------------------------------------------------

    // Store document context
    const setDocContext = (text, name) => {
      chatApp.docContext = trimContext(text || "");
      chatApp.docName = name || "document";
      updateStatus(`Loaded ${chatApp.docName}`);
      updateDocStatus();
    };

    const setDocContextFromFile = async (file) => {
      const text = await extractTextFor(file, { purpose: "doc" });
      const originalLength = text.length;

      setDocContext(text, file.name); // uses trimContext() internally

      showToast("Doc uploaded successfully!", { type: "success", delay: 5000 });

      if (originalLength > chatApp.maxDocChars) {
        setTimeout(() => {
          showToast(
            `Document was truncated from ${originalLength.toLocaleString()} to ` +
            `${chatApp.maxDocChars.toLocaleString()} characters to stay within limits.`,
            { type: "info", delay: 5000 }
          );
        }, 3000);
      }
    };

    // Clear document context
    const clearDocContext = () => {
      chatApp.docContext = "";
      chatApp.docName = "";
      updateStatus("Document context cleared");
      updateDocStatus();
      setTimeout(() => {
        updateStatus("Ready");
      }, 3500);
    };

    const embedFile = async (file) => {
      if (!isSupportedForEmbed(file)) {
        throw new Error("Unsupported file for embeddings");
      }
      const text = await extractTextFor(file, { purpose: "embed" });
      console.log(
        `[embedFile] ${file.name}: embeddable length=${(text || "").length}`
      );

      await embedAndStoreTextChunks({
        text,
        sourceName: file.name,
        showLog: (msg) => console.log(`[${file.name}]: ${msg}`),
        getApiKey,
      });

      // Track available RAG sources
      chatApp.ragSources = chatApp.ragSources || new Set();
      chatApp.enabledRagSources = chatApp.enabledRagSources || new Set();

      chatApp.ragSources.add(file.name);
      chatApp.enabledRagSources.add(file.name);

      renderEmbeddingSourcesUI();
      saveEnabledSources();

      // Optional: show sources in status
      updateDocStatus();
    };

    const ingestFile = async (
      file,
      { toDocContext = false, toEmbeddings = false } = {}
    ) => {
      let didDoc = false;
      let didEmbed = false;
      let errors = [];

      if (toDocContext) {
        try {
          await setDocContextFromFile(file);
          didDoc = true;
        } catch (e) {
          errors.push(`Doc context: ${e.message}`);
        }
      }

      if (toEmbeddings) {
        try {
          await embedFile(file);
          didEmbed = true;
          showToast(`Embedded: '${file.name}'`, {
            type: "success",
            delay: 2500,
          });
        } catch (e) {
          errors.push(`Embeddings: ${e.message}`);
        }
      }

      return { didDoc, didEmbed, errors };
    };

    // Helper to check if a file is already embedded
    const isFileAlreadyEmbedded = async (filename) => {
      try {
        const vectors = await getAllEmbeddings({ source: filename });
        return vectors && vectors.length > 0;
      } catch (err) {
        console.warn("Error checking for existing embeddings:", err);
        return false;
      }
    };

    // ---------------------------------------------------------------
    // 17. BUBBLE STATE MANAGEMENT
    // ---------------------------------------------------------------

    const prepareBubbleForStreaming = (botBubbleEl) => {
      if (!botBubbleEl) return;

      // Disconnect any existing scroll observers
      if (botBubbleEl._scrollObserver) {
        botBubbleEl._scrollObserver.disconnect();
        delete botBubbleEl._scrollObserver;
      }

      botBubbleEl.classList.add("streaming");
      const contentEl = botBubbleEl.querySelector(".message-content");
      if (contentEl) contentEl.innerHTML = "";

      botBubbleEl.querySelectorAll(".message-actions").forEach((n) => n.remove());

      // Ensure no shimmer yet
      botBubbleEl.querySelector(".typing-shimmer")?.remove();

      // Ensure dots are present
      showTypingDots(botBubbleEl);
    };

    const ensureActionBar = (bubble) => {
      let bar = bubble.querySelector(".message-actions");
      if (!bar) {
        bar = document.createElement("div");
        bar.className = "message-actions d-flex justify-content-end";
        bubble.appendChild(bar);
      } else {
        bar.classList.add("justify-content-end");
      }
      return bar;
    };

    // ---------------------------------------------------------------
    // 18. IMAGE GENERATION
    // ---------------------------------------------------------------

    // Fetch Image Call
    const generateImage = async (prompt) => {
      const apiKey = getApiKey();
      if (!apiKey) throw new Error("API key not configured");

      const response = await fetch(
        "https://api.openai.com/v1/images/generations",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model: "dall-e-3",
            prompt: prompt,
            n: 1,
            size: "1024x1024",
          }),
          signal: chatApp.currentController?.signal,
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error?.message || `HTTP ${response.status}`);
      }

      const data = await response.json();
      if (!data.data || !data.data[0]?.url)
        throw new Error("No image returned.");
      // Return both url and id (if exists)
      return {
        url: data.data[0].url,
        image_id: data.data[0].id,
        prompt: prompt,
      };
    };

    const createImageWithDownloadButton = (imageUrl, altText = "") => {
      const html = `
	    <div class="img-block-wrapper">
	      <img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(altText)}">
	      <button type="button"
	              class="btn btn-sm btn-outline-secondary img-download-btn"
	              title="Download image"
	              aria-label="Download image">
	        ${downloadSVG}
	      </button>
	    </div>
	  `.trim();

      // Parse the HTML string into live DOM
      const node = document
        .createRange()
        .createContextualFragment(html).firstElementChild;

      // Attach event listener
      const btn = node.querySelector(".img-download-btn");
      addListener(btn, "click", (e) => {
        e.preventDefault();
        const img = node.querySelector("img");
        downloadImage(img.src, img.alt || "");
      });

      return node;
    };

    const renderSingleImageIntoMessage = (botMessageEl, { url, alt, caption }) => {
      if (!botMessageEl) return;
      const contentEl = botMessageEl.querySelector(".message-content");
      if (!contentEl) return;

      // Clear spinner/placeholder
      contentEl.innerHTML = "";

      const block = createImageWithDownloadButton(
        url,
        alt || "generated image"
      );
      contentEl.appendChild(block);

      if (caption) {
        const cap = document.createElement("div");
        cap.className = "small ms-2 mt-2";
        cap.textContent = caption;
        contentEl.appendChild(cap);
      }
    };

    const downloadImage = async (url, name) => {
      //      try {
      //        const res = await fetch(url, { mode: "cors" });
      //        const blob = await res.blob();
      //        const a = document.createElement("a");
      //        a.href = URL.createObjectURL(blob);
      //        a.download = (name || "image") + ".png";
      //        document.body.appendChild(a);
      //        a.click();
      //        a.remove();
      //        URL.revokeObjectURL(a.href);
      //      } catch {
      //        showToast(
      //          "Unable to download image in this environment.\n Right-click instead",
      //          { type: "warning" }
      //        );
      //      }
      showToast(
        "Unable to download image in this environment.\n Right-click instead",
        { type: "warning" }
      );
    };

    // ---------------------------------------------------------------
    // 19. STREAMING & API COMMUNICATION
    // ---------------------------------------------------------------

    // Build payload dynamically with the correct token field name
    const buildChatPayload = (history, meta = null) => {
      const cfg = getActiveModelConfig();
      //console.debug("Model cfg: ", cfg);
      
      const payload = {
        model: cfg.id,
        input: history,
        stream: true,
      };
      // Use the correct token field per model
      payload[cfg.tokenField] = cfg.defaultMax;
      // Add reasoning effort if it exists in the config
      if (cfg.reasoning) {
         payload.reasoning = { effort: cfg.reasoning.effort };
      }

	  // Top-level metadata – allowed by /v1/responses
	  if (meta) {
	    payload.metadata = {
	      type: meta.type || "default",
	      hasDoc: String(meta.hasDoc),      // Convert boolean to string
	      hasRag: String(meta.hasRag),      // Convert boolean to string
	    };
	  }
  
      //console.debug("payload: ", payload);
      return payload;
    };

    // Helper to perform the fetch call
    const fetchChatCompletion = (apiKey, history, contextMeta = null) => {
      const payload = buildChatPayload(history, contextMeta);

      return fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify(payload),
        signal: chatApp.currentController?.signal,
      });
    };

    // Update Streaming Content
    const lastUpdateMap = new WeakMap();

    const updateStreamingContent = (contentEl, text) => {
      const now = Date.now();
      const last = lastUpdateMap.get(contentEl) || 0;
      if (now - last < 200) return; // throttle to ~5 fps
      lastUpdateMap.set(contentEl, now);
      contentEl.innerHTML = markdownToHtml(text);
    };

    // Handle each v1/responses streaming event
const handleChunk = (chunk, contentEl, fullResponse) => {
  try {
    const lines = chunk.split("\n").filter((l) => l.trim());
    for (const line of lines) {
      if (!line.startsWith("data: ")) continue;

      const jsonStr = line.slice(6).trim();
      if (jsonStr === "[DONE]") continue;

      let parsed;
      try {
        parsed = JSON.parse(jsonStr);
      } catch {
        console.warn("Skipping incomplete JSON:", jsonStr);
        continue;
      }

      // v1/responses streaming format
      // -----------------------------
      // TEXT TOKEN DELTA
      if (parsed.type === "response.output_text.delta") {
        const delta = parsed.delta;
        if (delta) {
          const wasEmpty = !fullResponse.current;
          fullResponse.current += delta;

          if (wasEmpty) startStreamingVisuals(contentEl);
          updateStreamingContent(contentEl, fullResponse.current);
        }
      }

      // FINAL OUTPUT (non-streaming fallback)
      if (parsed.output_text) {
        fullResponse.current = parsed.output_text;
        updateStreamingContent(contentEl, fullResponse.current);
      }
    }
  } catch (err) {
    console.error("handleChunk error:", err);
  }
};

    // Helper to process streaming response with UI cleanup
    const processResponseStream = async (response, contentEl) => {
      let parentBubble = contentEl.closest(".bot-message");
      if (!parentBubble) return "";

      const reader = response.body.getReader();
      chatApp.currentReader = reader;
      const decoder = new TextDecoder();

      let fullResponse = { current: "" };
      let buffer = "";

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });

          const lines = buffer.split("\n");
          buffer = lines.pop() || "";

          for (const line of lines) {
            if (line.trim()) {
              await handleChunk(line + "\n", contentEl, fullResponse);
            }
          }
        }

        if (buffer.trim()) {
          await handleChunk(buffer, contentEl, fullResponse);
        }
      } catch (error) {
        throw error; // Propagate the error up
      } finally {
        try {
          reader.releaseLock();
        } catch {}
        chatApp.currentReader = null;
      }

      return fullResponse.current;
    };

    // Helper to handle fetch errors
    const handleFetchError = async (response) => {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error?.message || `HTTP ${response.status}`);
    };

    // StreamResponse function
    const streamResponse = async (
      history,
      botMessageEl,
      contextMeta,
      { isRetry = false } = {}
    ) => {
      let follow;
      try {
        const contentEl = botMessageEl.querySelector(".message-content");
        if (!contentEl) return;

        //contentEl.innerHTML = ""; // Clear previous content
        // Keep the typing dots placeholder until first tokens arrive
        if (!contentEl.querySelector(".typing-dots")) {
          contentEl.appendChild(createTypingDots());
        }

        // --- Ensure the message is visible as soon as new message comes in ---
        follow = ensureVisible(botMessageEl);
        follow.snap();

        const apiKey = getApiKey();
        if (!apiKey) throw new Error("API key not configured");

        const response = await fetchChatCompletion(apiKey, history, contextMeta);
        if (!response.ok) {
          await handleFetchError(response);
          return;
        }

        // Process and display streaming response
        const fullResponse = await processResponseStream(response, contentEl);
        updateMessageHistory(fullResponse, { isRetry });
        finalizeContent(contentEl, fullResponse);

        try {
          // Attach retry so user can quickly re-ask the same prompt
          const botBubbleEl = contentEl.closest(".message-bubble.bot-message");
          if (botBubbleEl)
            attachRetryToBotBubble(
              botBubbleEl,
              chatApp.lastPrompt || getLastUserPrompt()
            );
        } catch { }
      } catch (error) {
        throw error;
      } finally {
        // Always disconnect follow
        if (follow) follow.disconnect();
      }
    };

    const stopStreaming = async () => {
      if (chatApp._stopping || !chatApp.isStreaming) return; // Prevent multiple calls
      chatApp._stopping = true;
      //console.log("Stopping stream...");

      // Abort fetch
      if (chatApp.currentController) {
        try {
          chatApp.currentController.abort();
        } catch { }
      }
      // Cancel the reader
      if (chatApp.currentReader) {
        try {
          await chatApp.currentReader.cancel();
        } catch { }
      }

      // Let the handleSend catch block and finally block handle the rest.
      chatApp._stopping = false;
    };

    // ---------------------------------------------------------------
    // 20. CONVERSATION FLOWS (depends on streaming)
    // ---------------------------------------------------------------

    const buildMessagesWithContext = ({
      userPrompt,
      ragContext = "", // Pre-formatted from getRagContextForPrompt(): "[1] ... \n\n-----\n\n[2] ..."
      docContext = null,
      includeHistory = true, // Include conversation history from chatApp.messageHistory
    }) => {
      const messages = [];

      // --- SAFETY GUARD: remove invalid history items ---
	  const safeHistory = (chatApp.messageHistory || []).filter(
	    (m) =>
	      m &&
	      typeof m === "object" &&
	      typeof m.role === "string" &&
	      typeof m.content === "string"
	  );	

      const hasDoc = !!docContext && docContext.trim().length > 0;
      const hasRag = !!ragContext && ragContext.trim().length > 0;

      // 1) Add system messages (base instructions + context instructions)
      if (includeHistory) {
        const systemMsgs = safeHistory.filter((msg) => msg.role === "system");
        messages.push(...systemMsgs);
      }

      // 2) Build and inject citation instructions
      if (hasDoc || hasRag) {
        let citationInstructions = CONTEXT_INSTRUCTIONS.base;

        if (hasDoc && hasRag) {
          citationInstructions += "\n" + CONTEXT_INSTRUCTIONS.hybrid;
        } else if (hasDoc) {
          citationInstructions += "\n" + CONTEXT_INSTRUCTIONS.docOnly;
        } else if (hasRag) {
          citationInstructions += "\n" + CONTEXT_INSTRUCTIONS.ragOnly;
        }

        messages.push({
          role: "system",
          content: citationInstructions,
        });

        // 3) Build and inject the actual context
        let contextContent = "";

        if (hasDoc) {
          contextContent += `### Uploaded Document (Background Context):\n**File:** ${chatApp.docName || "Document"}\n\n${docContext}\n\n`;
        }

        if (hasRag) {
          contextContent += `### Retrieved Snippets (Ranked by Relevance, from Vector Database):\n${ragContext}\n`;
        }

        messages.push({
          role: "system",
          content: contextContent,
        });
      }

      // 4) Add conversation history (if enabled)
      if (includeHistory) {
        const convoMsgs = safeHistory.filter((msg) => msg.role !== "system");
        messages.push(...convoMsgs);
      }

      // 5) Add current user prompt (dedupe check)
      if (includeHistory) {
        const convoMsgs = safeHistory.filter((msg) => msg.role !== "system");
        const lastConvoUser =
	  convoMsgs.length > 0 ? convoMsgs[convoMsgs.length - 1] : null;
        
	const shouldPushUserPrompt =
          !lastConvoUser ||
          lastConvoUser.role !== "user" ||
          lastConvoUser.content !== userPrompt;

        if (shouldPushUserPrompt) {
          messages.push({ role: "user", content: userPrompt });
        }
      } else {
        // No history mode: just add the user prompt
        messages.push({ role: "user", content: userPrompt });
      }
      //console.log("[buildMessagesWithContext] : ", messages);
       // Return both messages and your context-related meta
	  return {
	    messages,
	    contextMeta: {
	      type: "context",
	      hasDoc,
	      hasRag,
	    },
	  };
	};

    const handleTextPromptFlow = async ({
      prompt,
      botMessageEl,
      isRetry = false,
    }) => {

      try {
        updateStatus("Retrieving context...");

        // If enabledRagSources has been initialized and is empty -> user explicitly disabled RAG
        const enabledSet = chatApp.enabledRagSources;
        let rag = { context: "", citations: [] };

        if (!(enabledSet && enabledSet.size === 0)) {
          const sourcesToUse =
            enabledSet && enabledSet.size > 0 ? Array.from(enabledSet) : null; // null = all
          console.log(
            "[RAG] Using embedded sources for context:",
            sourcesToUse ? sourcesToUse.join(", ") : "ALL (no filter)"
          );
          rag = await getRagContext(prompt, {
            sources: sourcesToUse,
            topK: chatApp.rag.topK,
            minSim: chatApp.rag.minSim,
            budgetTokens: chatApp.rag.budgetTokens,
            minSnippetTokens: chatApp.rag.minSnippetTokens,
          });
        }

        updateStatus("Sending to OpenAI...");

        // If buildMessagesWithContext includes conversation history, we’ll remove the last assistant on retry.
        // If it only builds a fresh system/context + user message (no prior assistant), the strip step is a no-op.
        let { messages, contextMeta } = buildMessagesWithContext({
	  userPrompt: prompt,
	  ragContext: rag.context,
	  docContext: chatApp.docContext,
	});
	
	if (isRetry) messages = stripLastAssistant(messages);
	
	// Pass both into streamResponse so fetchChatCompletion can use them
	await streamResponse(
	  messages,
	  botMessageEl,
	  contextMeta,
	  { isRetry }
	); // pass isRetry through

        if (rag?.citations?.length) {
          appendCitations(botMessageEl, rag.citations, { dedupe: true });
        }
      } catch (error) {
        console.error('[TextFlow] Error:', error);
        // Re-throw so executeStreamingFlow can handle UI updates
        throw error;
      }
    };

    const handleImagePromptFlow = async ({ prompt, botMessageEl, isRetry = false }) => {
      let follow;

      try {
        // Start following BEFORE the API call so user sees the bubble immediately
        follow = ensureVisible(botMessageEl);
        follow.snap();

        updateStatus("Generating image...");
        const { url, image_id } = await generateImage(prompt);

        // Track in your image library
        const imageInfo = {
          id: Date.now().toString(36),
          url,
          prompt,
          image_id,
        };
        chatApp.images.push(imageInfo);

        renderSingleImageIntoMessage(botMessageEl, {
          url,
          alt: prompt || "generated image",
          caption: prompt,
        });

        // Increment message history & counter
        updateMessageHistory("Generated an image.", { isRetry });

        // Find the actual <img> we inserted
        const img = botMessageEl.querySelector(".img-block-wrapper img");
        if (img) {
          const onLoad = () => {
            if (follow) {
              try {
                // Force alignment now that the image size is available
                follow.resume();
              } catch (e) { }

              // Disconnect after a short delay to catch any final layout shifts
              setTimeout(() => {
                try {
                  follow.disconnect();
                } catch (e) { }
              }, 250);
            }
          };

          if (img.complete) {
            // Handle cached image (already loaded)
            onLoad();
          } else {
            addListener(img, "load", onLoad, { once: true, passive: true });
            // Also handle error case so observer is cleaned up
            addListener(img, "error", () => {
              if (follow) {
                try {
                  follow.disconnect();
                } catch { }
              }
            },
              { once: true }
            );
          }
        } else {
          // Fallback: no img found — disconnect after a short timeout
          setTimeout(() => {
            if (follow) {
              try {
                follow.disconnect();
              } catch { }
            }
          }, 300);
        }
      } catch (error) {
        // Clean up follow observer if there's an error
        if (follow) {
          try {
            follow.disconnect();
          } catch { }
        }
        throw error; // Re-throw so caller can handle
      }
    };

    // ---------------------------------------------------------------
    // 21. RETRY ACTIONS (forward declaration for circular dependency)
    // ---------------------------------------------------------------

    let executeStreamingFlow;

    // Retry from an existing bot bubble (regenerate response)
    const retryFromBotBubble = async (botBubbleEl) => {
      if (chatApp.isStreaming) {
        showToast("Already streaming. Please wait or press Stop.", {
          type: "warning",
        });
        return;
      }

      const prompt =
        botBubbleEl?.dataset?.prompt ||
        chatApp.lastPrompt ||
        getLastUserPrompt();
      if (!prompt) {
        showToast("No prompt available to retry.", { type: "warning" });
        return;
      }

      // Execute flow with existing bubble
      await executeStreamingFlow({
        prompt,
        botMessageEl: botBubbleEl,
        isRetry: true,
      });
    };

    const attachRetryToBotBubble = (botBubbleEl, prompt) => {
      if (!botBubbleEl) return;

      botBubbleEl.dataset.prompt =
        prompt || botBubbleEl.dataset.prompt || getLastUserPrompt();

      const bar = ensureActionBar(botBubbleEl);

      // Remove any existing retry buttons and clean up tooltip if it belongs to them
      bar.querySelectorAll(".btn-retry").forEach((b) => {
        if (tooltipManager.element === b) {
          tooltipManager.dispose();
        }
        b.remove();
      });

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn btn-outline-secondary btn-retry border-0 me-1";
      btn.dataset.bsPlacement = "bottom";
      btn.innerHTML = '<i class="bi bi-arrow-repeat"></i>';
      btn.setAttribute("aria-label", "Retry response");

      // Click handler
      addListener(btn, "click", async () => {
        // Ensure any visible tooltip is removed before retrying
        tooltipManager.hide();
        await retryFromBotBubble(botBubbleEl);
      });

      // Tooltip behavior via tooltipManager (manual show/hide for consistency)
      const showTip = () =>
        tooltipManager.show(btn, "Retry response"); // internally creates with defaults
      const hideTip = () => tooltipManager.hide();

      // Hover + focus accessibility
      addListener(btn, "mouseenter", showTip);
      addListener(btn, "mouseleave", hideTip);
      addListener(btn, "focus", showTip);
      addListener(btn, "blur", hideTip);

      bar.appendChild(btn);

      return btn;
    };

    // ---------------------------------------------------------------
    // 22. STREAMING FLOW ORCHESTRATION
    // ---------------------------------------------------------------

    //  Handles errors during streaming with consistent UI updates
    const handleStreamingError = async (
      error,
      { prompt, botMessageEl, userMessageEl }
    ) => {
      const isAborted = isAbortLike?.(error);

      if (isAborted) {
        updateStatus("Response stopped by user.");
        updateConnectionStatus("disconnected");
      } else {
        const errorMsg = error?.message || "An unexpected error occurred";
        updateStatus(`Error: ${errorMsg}`);
        updateConnectionStatus("disconnected");

        // Update bot bubble with error message
        if (botMessageEl) {
          const contentEl = botMessageEl.querySelector?.(".message-content");
          if (contentEl) contentEl.textContent = `Error: ${errorMsg}`;
        }
      }

      // Always attach retry button (for both aborts and errors)
      if (botMessageEl) {
        attachRetryToBotBubble(botMessageEl, prompt);
      }
    };

    // Cleans up streaming state and UI
    const cleanupStreamingState = (botMessageEl) => {
      chatApp.isStreaming = false;
      toggleInput(true);
      restoreSendButton();
      chatApp.currentController = null;
      updateSendButtonState();

      if (botMessageEl) {
        const bubbleEl = botMessageEl.bubble ?? botMessageEl;
        // Remove shimmer
        bubbleEl.classList?.remove("streaming");
        bubbleEl.querySelector?.(".typing-shimmer")?.remove();
        // Remove typing dots (if still present)
        hideTypingDots(bubbleEl);
      }
    };

    //  Central function that handles the complete streaming lifecycle
    executeStreamingFlow = async ({
      prompt,
      botMessageEl = null,
      userMessageEl = null,
      isImageFlow = false,
      isRetry = false,
    }) => {
      // Setup phase
      const controller = new AbortController();
      chatApp.currentController = controller;
      chatApp.isStreaming = true;

      toggleInput(false, { keepSendEnabled: true });
      updateConnectionStatus("connecting");
      setSendButtonToStop();

      // Prepare bot bubble for streaming (dots only; no shimmer yet)
      const bubbleEl = botMessageEl?.bubble ?? botMessageEl;
      if (bubbleEl) {
        prepareBubbleForStreaming(bubbleEl); // shows three dots only
      }

      try {
        // Execute the appropriate flow
        // Pass the bubble element to the flow functions
        if (isImageFlow) {
          await handleImagePromptFlow({
            prompt,
            botMessageEl: bubbleEl,
            isRetry,
          });
          updateConnectionStatus("connected");
          updateStatus("Image generated");
        } else {
          await handleTextPromptFlow({
            prompt,
            botMessageEl: bubbleEl,
            isRetry,
          });
          updateConnectionStatus("connected");
          updateStatus("Response completed");
        }
      } catch (error) {
        await handleStreamingError(error, {
          prompt,
          botMessageEl: bubbleEl,
          userMessageEl,
        });
      } finally {
        cleanupStreamingState(botMessageEl);
      }
    };

    // ---------------------------------------------------------------
    // 23. USER ACTIONS & INPUT HANDLING
    // ---------------------------------------------------------------

    const toggleInput = (enabled, { keepSendEnabled = false } = {}) => {
      const { promptInput, sendBtn } = chatApp.els;
      if (promptInput) promptInput.disabled = !enabled;

      // Keep Send enabled while streaming so it can act as "Stop"
      if (sendBtn) sendBtn.disabled = keepSendEnabled ? false : !enabled;

      if (enabled && promptInput) {
        promptInput.focus();
        autoResize();
      }
    };

    const autoResize = () => {
      const input = chatApp.els.promptInput;
      if (!input) return;

      input.style.height = "auto";

      const minHeight = 40;
      const maxHeight = window.innerWidth <= 768 ? 160 : 200;
      const scrollHeight = input.scrollHeight;

      input.style.height = `${Math.max(
        minHeight,
        Math.min(scrollHeight, maxHeight)
      )}px`;
      input.style.overflowY = scrollHeight > maxHeight ? "auto" : "hidden";
    };

    const updateSendButtonState = () => {
      const input = chatApp.els.promptInput;
      const button = chatApp.els.sendBtn;
      if (!input || !button) return;
      if (chatApp.isStreaming) {
        button.disabled = false; // remain clickable as "Stop"
        return;
      }
      button.disabled = input.value.trim().length < 2; // enable button when 2 chars
    };

    const handleKeyDown = (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        updateSendButtonState(); // Ensure validation before handling send
        if (!chatApp.els.sendBtn.disabled) {
          handleSend();
        }
      }
    };

    // Handles new message submission from user
    const handleSend = async () => {
      const { promptInput } = chatApp.els;
      const prompt = promptInput?.value.trim();
      if (!prompt) return;

      // Abort any existing stream
      if (chatApp.currentController) chatApp.currentController.abort();

      // Display user message
      const userMsg = displayMessage(prompt, "user");
      promptInput.value = "";
      autoResize();
      updateSendButtonState();
      updateMessageCount();

      // Create bot bubble
      const botMsg = displayMessage("", "assistant", "streaming");
      if (botMsg?.wrapper) botMsg.wrapper.dataset.prompt = prompt;
      chatApp.lastPrompt = prompt;

      // Add to history
      chatApp.messageHistory ??= [
        { role: "system", content: `${SYSTEM_PROMPT}` },
      ];
      chatApp.messageHistory.push({ role: "user", content: prompt });

      //prune before building/sending the next request
      pruneHistory();

      // Execute flow
      await executeStreamingFlow({
        prompt,
        botMessageEl: botMsg,
        userMessageEl: userMsg?.bubble,
        isImageFlow: chatApp.isImagePrompt,
      });
    };

    // Clear Chat History - New Chat
    const clearChat = () => {
      if (chatApp.currentController) {
        try {
          chatApp.currentController.abort();
        } catch { }
        chatApp.currentController = null;
      }

      const { chatContainer, promptInput, messageCount } = chatApp.els;
      chatContainer.textContent = ""; // clear

      promptInput.value = "";
      chatApp.messageCount = 0;
      chatApp.messageHistory = [{ role: "system", content: `${SYSTEM_PROMPT}` }];
      messageCount.textContent = "0 messages";

      updateSendButtonState();
      autoResize();
      clearDocContext();
      updateStatus("Ready");

      // Welcome line using the same renderer
      displayMessage("Chat cleared. How can I help you today?", "assistant");

      setTimeout(() => promptInput.focus(), 200);
    };

    // ---------------------------------------------------------------
    // 24. MODE MANAGEMENT (image pills)
    // ---------------------------------------------------------------

    const ensurePillsContainer = () => {
      // Put pills container in the LEFT controls col, right next to the plus button
      const leftCol = chatApp.els.row.querySelector(".col-auto:first-child");
      let container = leftCol?.querySelector(".mode-pills");
      if (!container) {
        container = document.createElement("div");
        container.className = "mode-pills";
        leftCol.appendChild(container); // after the dropdown (plus button)
      }
      return container;
    };

    const addImagePill = () => {
      const pills = ensurePillsContainer();
      if (pills.querySelector('.pill[data-kind="image"]')) return; // no duplicates

      const pill = document.createElement("span");
      pill.className = "pill";
      pill.dataset.kind = "image";

      pill.innerHTML = `
	    <span class="pill-icon">${imageSVG}</span>
	    <span class="pill-label">Image</span>
	    <button type="button" class="close" aria-label="Remove image">&times;</button>
	  `;

      const close = pill.querySelector(".close");
      addListener(close, "click", () => {
        setImageMode(false);
        chatApp.els.promptInput?.focus();
      });

      pills.appendChild(pill);
      chatApp.els.promptInput.placeholder = "Describe your image ...";
    };

    const removeImagePill = () => {
      const pill = chatApp.els.row.querySelector('.pill[data-kind="image"]');
      pill?.remove();

      const container = chatApp.els.row.querySelector(".mode-pills");
      if (container && container.children.length === 0) {
        container.remove();
      }
      chatApp.els.promptInput.placeholder =
        "Type your message ... (Shift+Enter for new line)";
    };

    const setImageMode = (on) => {
      const isOn = !!on;
      chatApp.isImagePrompt = isOn;
      chatApp.els.inputArea.classList.toggle("image-mode", isOn);
      isOn ? addImagePill() : removeImagePill();
    };

    // ---------------------------------------------------------------
    // 25. EVENT HANDLERS
    // ---------------------------------------------------------------

    const ensureFileInput = (e) => {
      const { els } = chatApp;
      // Find or create the hidden file input
      let docInputEl = els.docInput;
      if (!docInputEl) {
        docInputEl = document.createElement("input");
        Object.assign(docInputEl, {
          type: 'file',
          id: 'docInput',
          className: 'd-none',
          accept: '.txt,.md,.htm,.html,.pdf,.docx'
        });

        if (!docInputEl._bound) {
          addListener(docInputEl, "change", (e) => {
            handleDocumentUpload(e);
            setTimeout(() => els.promptInput?.focus(), 300);
          });
          docInputEl._bound = true;
        }

        document.body.appendChild(docInputEl);
        els.docInput = docInputEl;
      }
      return docInputEl;
    };

    const handleDocumentUpload = async (event) => {
      const file = event.target.files?.[0];
      if (!file) return;

      // Accept TXT, PDF, DOCX, HTML
      const allowedExt = /\.(txt|pdf|docx|htm|html|md)$/i;
      const name = normalizeName(file);
      console.log(
        "[handleDocumentUpload] uploading:",
        name,
        "type:",
        file.type
      );

      if (!allowedExt.test(name)) {
        showToast("Please upload a TXT, PDF, DOCX, MD, or HTML file.", {
          type: "warning",
        });
        event.target.value = "";
        return;
      }

      try {
        // Set Doc Context only
        await ingestFile(file, { toDocContext: true, toEmbeddings: false });
      } catch (err) {
        console.error("Upload processing error:", err);
        showToast("There was a problem processing your file.", {
          type: "danger",
        });
      } finally {
        event.target.value = ""; // allow re-upload of the same file
      }
    };

    // Context menu handler with visual feedback
    const handleDocContextMenu = (e) => {
      e.preventDefault();

      if (!chatApp.docContext) {
        showToast("No document to clear!");
        return;
      }

      // Clear document and show confirmation
      clearDocContext();
    };

    const handleClearChat = (e) => {
      hideTooltip(e.currentTarget);
      e.currentTarget.blur();
      // Show Bootstrap modal
      getOrCreateModal(chatApp.els.clearChatModal).show();
    };

    const handlePromptInput = () => {
      autoResize();
      updateSendButtonState();
    };

    const handlePromptPaste = () => {
      setTimeout(() => {
        autoResize();
        updateSendButtonState();
      }, 10);
    };

    // Window Resize
    let resizeTimeout;

    const handleWindowResize = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (chatApp.els.promptInput) {
          autoResize();
        }
      }, 100); // Only run resize logic after 100ms of no resize events
    };

    const onEmbedInputChange = async (event) => {
      const files = Array.from(event.target.files || []);
      if (!files.length) {
        showToast("No files selected.", { type: "warning" });
        return;
      }

      showToast(
        `Processing ${files.length} file${files.length === 1 ? "" : "s"}...`,
        { type: "info" }
      );

      let filesProcessed = 0;
      let filesFailed = 0;
      let filesReplaced = 0;
      const failedFiles = [];

      for (const file of files) {
        if (!isSupportedForEmbed(file)) {
          showToast(`Skipping '${file.name}' (unsupported type)`, {
            type: "warning",
          });
          filesFailed++;
          failedFiles.push({ name: file.name, error: "Unsupported file type" });
          continue;
        }

        try {
          // Check if file is already embedded
          const alreadyEmbedded = await isFileAlreadyEmbedded(file.name);

          if (alreadyEmbedded) {
            // The file stays in enabledRagSources since it's being replaced.
            const deletedCount = await deleteEmbeddingsForSource(file.name);
            console.log(
              `Auto-replacing: deleted ${deletedCount} embeddings for '${file.name}'`
            );
            filesReplaced++;
          }

          const result = await ingestFile(file, {
            toDocContext: false,
            toEmbeddings: true,
          });

          if (result.errors && result.errors.length > 0) {
            filesFailed++;
            const errorMsg = result.errors.join("; ");
            failedFiles.push({ name: file.name, error: errorMsg });
            showToast(`Error embedding '${file.name}': ${errorMsg}`, {
              type: "danger",
              delay: 4800,
            });

            // Error handling with cleanup: Remove from enabled sources on failure.
            chatApp.enabledRagSources?.delete(file.name);
            await saveEnabledSources();
          } else if (result.didEmbed) {
            filesProcessed++;
          } else {
            filesFailed++;
            failedFiles.push({
              name: file.name,
              error: "Unknown error - no embedding performed",
            });

            chatApp.enabledRagSources?.delete(file.name);
            await saveEnabledSources();
          }
        } catch (err) {
          filesFailed++;
          const errorMsg = err.message || "Unknown error";
          failedFiles.push({ name: file.name, error: errorMsg });
          showToast(`Error embedding '${file.name}': ${errorMsg}`, {
            type: "danger",
            delay: 4800,
          });

          chatApp.enabledRagSources?.delete(file.name);
          await saveEnabledSources();
        }

        // UI refresh: Update the checkbox list after success or failure.
        renderEmbeddingSourcesUI();
      }

      // Final summary with all stats
      const summaryParts = [];
      if (filesProcessed > 0) {
        summaryParts.push(
          `embedded ${filesProcessed} file${filesProcessed === 1 ? "" : "s"}`
        );
      }
      if (filesReplaced > 0) {
        summaryParts.push(
          `replaced ${filesReplaced} file${filesReplaced === 1 ? "" : "s"}`
        );
      }

      if (summaryParts.length > 0) {
        showToast(`Successfully ${summaryParts.join(", ")}.`, {
          type: "success",
          delay: 3000,
        });
        updateDocStatus();
      }

      if (filesFailed > 0) {
        console.error("Failed embeddings:", failedFiles);
        showToast(
          `Failed to embed ${filesFailed} file${filesFailed === 1 ? "" : "s"
          }. Check console for details.`,
          { type: "danger", delay: 4000 }
        );
      }

      event.target.value = "";
    };

    // ---------------------------------------------------------------
    // 26. INITIALIZATION
    // ---------------------------------------------------------------

    // Initialize Object Elements
    const initElements = async () => {
      chatApp.els = {
        chatContainer: document.getElementById("chatContainer"),
        inputArea: document.querySelector(".input-area"),
        row: document.querySelector(".input-area .row"),
        promptInput: document.getElementById("promptInput"),
        sendBtn: document.getElementById("sendBtn"),
        clearChat: document.getElementById("clearChat"),
        clearChatModal: document.getElementById("clearChatModal"),
        clearModalBtn: document.getElementById("confirmClearChatBtn"),
        embedInput: document.getElementById("manageInputBtn"),
        createImageBtn: document.getElementById("createImage"),
        addContextBtn: document.getElementById("addContextBtn"),
        docInput: document.getElementById("docInput"),
        deleteFileContextBtn: document.getElementById("deleteFileContextBtn"),
        deleteAllEmbeddingsBtn: document.getElementById(
          "deleteAllEmbeddingsBtn"
        ),
        connectionStatus: document.getElementById("connectionStatus"),
        statusText: document.getElementById("statusText"),
        messageCount: document.getElementById("messageCount"),
        modelPicker: document.getElementById("modelPicker"),
      };
    };

    // Centralized Event Binding
    const bindEvents = async () => {
      if (chatApp._eventsBound) return;
      chatApp._eventsBound = true;

      const { els } = chatApp;

      // Model Picker
      els.modelPicker.value = chatApp.currentModelKey;

      addListener(els.modelPicker, "change", (e) => {
        chatApp.currentModelKey = e.target.value;
        // Optional: reset RAG settings each time the model changes
        initRagFromModel();
        updateDocStatus();
      });

      // Send button
      addListener(els.sendBtn, "click", () => {
        chatApp.isStreaming ? stopStreaming() : handleSend();
      });

      // Clear chat with tooltip handling
      addListener(els.clearChat, "click", handleClearChat);

      // Prompt input events      
      addListener(els.promptInput, "keydown", handleKeyDown);
      addListener(els.promptInput, "input", handlePromptInput);
      addListener(els.promptInput, "paste", handlePromptPaste);

      // Document upload events

      // On file chosen
      addListener(els.docInput, "change", (e) => {
        handleDocumentUpload(e);
        setTimeout(() => {
          els.promptInput?.focus();
        }, 300);
      });

      // Clear Modal events
      addListener(els.clearModalBtn, "click", () => {
        els.promptInput?.focus({ preventScroll: true });
        clearChat();
        // Hide modal after clearing:
        const modalEl = document.getElementById("clearChatModal");
        if (modalEl) {
          const modal = getOrCreateModal(modalEl);
          setTimeout(() => modal.hide(), 150);
        }
      });

      // Move Focus
      const bsModals = document.querySelectorAll(".modal");
      bsModals.forEach((modal) => {
        // Before modal hides: move focus away
        addListener(modal, "hide.bs.modal", () => {
          blurAllOpenModals();
          // Move focus to another element
          els.promptInput?.focus({ preventScroll: true });
        });

        // After modal is hidden: set inert
        addListener(modal, "hidden.bs.modal", () => {
          modal.setAttribute("inert", "");
        });

        // When modal is about to be shown: remove inert
        addListener(modal, "show.bs.modal", () => {
          modal.removeAttribute("inert");
        });
      });

      // Window events
      addListener(window, "resize", handleWindowResize);

      // RAG Settings
      els.settingsBtn = document.getElementById("settingsBtn");
      els.ragSettingsModal = document.getElementById("ragSettingsModal");
      els.ragSettingsForm = document.getElementById("ragSettingsForm");
      els.ragBudgetTokens = document.getElementById("ragBudgetTokens");
      els.ragMinSnippetTokens = document.getElementById("ragMinSnippetTokens");
      els.ragTopK = document.getElementById("ragTopK");
      els.ragMinSim = document.getElementById("ragMinSim");
      els.ragChunkTokens = document.getElementById("ragChunkTokens");
      els.ragOverlapTokens = document.getElementById("ragOverlapTokens");

      addListener(els.settingsBtn, "click", () => {
        populateRagFormFromState();
        // Load enabled sources from persistence or default on modal open
        if (!chatApp.enabledRagSources) {
          loadEnabledSources();
        }

        renderEmbeddingSourcesUI();

        getOrCreateModal(els.ragSettingsModal).show();
      });

      addListener(els.ragSettingsForm, "submit", (e) => {
        e.preventDefault();
        readRagFormIntoState();
        saveEnabledSources(); // persist the enabled set
        showToast("RAG settings applied.", { type: "success" });
        const modal = getOrCreateModal(els.ragSettingsModal);
        setTimeout(() => modal.hide(), 100);
        updateDocStatus();
      });

      // Show native file picker when "Add file for embedding" is clicked (handled by label)
      // --- Dropdown/Dropup menu wiring ---
      addListener(els.embedInput, "change", onEmbedInputChange);

      // Add file as context
      addListener(els.addContextBtn, "click", (e) => {
        const docInputEl = ensureFileInput(e);
        docInputEl.value = ""; // allow re-picking same file
        setTimeout(() => docInputEl.click(), 0);
      });

      // Wire the "Create image" dropdown item
      addListener(els.createImageBtn, "click", (e) => {
        e.preventDefault();
        setImageMode(true);
      });

      // sync UI to existing state on load/refresh
      setImageMode(!!chatApp.isImagePrompt);

      // Delete file context
      addListener(els.deleteFileContextBtn, "click", () => {
        if (!chatApp.docContext) {
          showToast("No document context to clear", { type: "info" });
          return;
        }
        clearDocContext();
        showToast("Document context cleared", { type: "success" });
      });

      // Delete all embeddings
      addListener(els.deleteAllEmbeddingsBtn, "click", async () => {
        if (!(await showConfirm(
          "Delete all embedded vectors? This cannot be undone."
        ))) {
          return;
        }

        try {
          els.deleteAllEmbeddingsBtn.disabled = true;
          const cleared = await clearEmbeddings();
          const message = `Cleared ${cleared ?? 0} embedded file${cleared === 1 ? '' : 's'}`;
          showToast(message, { type: 'success' });
        } catch (err) {
          console.error('Failed to clear embeddings:', err);
          showToast("Failed to clear embeddings", { type: "danger" });
        } finally {
          els.deleteAllEmbeddingsBtn.disabled = false;
        }
      });

      // Dropdown Menu for PLUS button  	
      addListener(document, "shown.bs.dropdown", (e) => {
        const dropdown = e.target; // the .dropdown element
        if (dropdown.contains(document.getElementById("embedAddBtn"))) {
          dropdown._openedAt = performance.now();
        }
      });

      addListener(document, "hide.bs.dropdown", (e) => {
        const dropdown = e.target;
        if (dropdown.contains(document.getElementById("embedAddBtn"))) {
          const elapsed = performance.now() - (dropdown._openedAt || 0);
          if (elapsed < DROPDOWN_MIN_OPEN_TIME) e.preventDefault();
        }
      });

    };

    // ---------------------------------------------------------------
    // 27. BOOT SEQUENCE (IIFE)
    // ---------------------------------------------------------------

    (() => {
      "use strict";

      // ---- Constants ----
      const DEBUG = true;

      const logger = {
        debug: (...a) => {
          if (DEBUG) console.debug("[PLBApp]", ...a);
        },
        info: (...a) => {
          if (DEBUG) console.info("[PLBApp]", ...a);
        },
        warn: (...a) => {
          if (DEBUG) console.warn("[PLBApp]", ...a);
        },
        error: (...a) => console.error("[PLBApp]", ...a),
        group: (label) => {
          if (DEBUG) console.group(label);
        },
        groupEnd: () => {
          if (DEBUG) console.groupEnd();
        },
      };

      const timedStep = async (label, fn) => {
        const start = performance.now();
        logger.debug(`--> ${label}...`);
        try {
          const result = await fn();
          logger.debug(
            `[+] ${label} (${(performance.now() - start).toFixed(1)}ms)`
          );
          return result;
        } catch (e) {
          logger.error(
            `[!->] ${label} failed after ${(performance.now() - start).toFixed(
              1
            )}ms:`,
            e
          );
          throw e;
        }
      };

      // ---- Wait Utilities ----

      const waitForGlobal = async (
        name,
        getter,
        { timeoutMs, intervalMs } = WAIT_CONFIG.DEFAULT
      ) => {
        const startTime = performance.now();

        while (performance.now() - startTime < timeoutMs) {
          const value = getter();
          if (value) return value;
          await new Promise(resolve => setTimeout(resolve, intervalMs));
        }

        throw new Error(`${name} not found within ${timeoutMs}ms`);
      };

      const waitForCondition = async (
        label,
        predicate,
        { timeoutMs, intervalMs } = WAIT_CONFIG.CONDITION
      ) => {
        const startTime = performance.now();

        while (performance.now() - startTime < timeoutMs) {
          try {
            if (predicate()) return true;
          } catch {
            // Ignore errors during predicate checks
          }
          await new Promise(resolve => setTimeout(resolve, intervalMs));
        }
        const elapsed = performance.now() - startTime;
        logger.debug(`${label} timeout after ${elapsed.toFixed(1)}ms`);
        throw new Error(`${label} not ready within ${timeoutMs}ms`);
      };

      // Idempotent configuration
      const ensureMarkedConfigured = (marked) => {
        const desiredConfig = {
          breaks: true,
          gfm: true,
          headerIds: false,
          mangle: false,
          pedantic: false,
        };

        // Check if configuration is needed
        const needsConfig = Object.entries(desiredConfig).some(
          ([key, value]) => marked.defaults?.[key] !== value
        );

        if (needsConfig) {
          marked.setOptions(desiredConfig);
        }

        // Apply custom renderer if available
        if (window.renderer && typeof window.renderer === "object") {
          marked.use({ renderer: window.renderer });
        }
      };

      const configurePrism = async () => {
        logger.group("Configure Prism");
        try {
          const Prism = await waitForGlobal(
            "Prism",
            () => window.Prism,
            WAIT_CONFIG.PRISM
          );

          // Strategy 1: Try autoloader with retry
          let autoloaderReady = false;
          const maxAutoloaderRetries = 5;

          for (let attempt = 1; attempt <= maxAutoloaderRetries; attempt++) {
            try {
              await waitForCondition(
                "Prism autoloader",
                () => !!Prism.plugins?.autoloader,
                WAIT_CONFIG.PRISM_AUTOLOADER
              );
              Prism.plugins.autoloader.languages_path =
                "https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/";
              logger.debug("Prism autoloader languages_path set.");
              autoloaderReady = true;
              break;
            } catch (e) {
              logger.debug(`Autoloader attempt ${attempt}/${maxAutoloaderRetries} failed.`);
              if (attempt < maxAutoloaderRetries) {
                await new Promise(resolve => setTimeout(resolve, 300));
              }
            }
          }

          // Strategy 2: If autoloader failed, load common languages directly
          if (!autoloaderReady) {
            logger.warn("Autoloader unavailable; loading fallback languages directly.");
            await loadPrismLanguages();
          }

          logger.debug("Prism ready (autoloader: " + (autoloaderReady ? "yes" : "fallback") + ")");
        } catch (e) {
          logger.error("Prism config critical failure:", e.message);
        } finally {
          logger.groupEnd();
        }
      };

      const configureMarked = async () => {
        logger.group("Configure marked");
        try {
          const marked = await waitForGlobal(
            "marked",
            () => window.marked,
            WAIT_CONFIG.MARKED
          );
          ensureMarkedConfigured(marked);
          chatApp.markedConfigured = true;
          logger.debug("marked configured. Current defaults:", marked.defaults);
        } catch (e) {
          logger.warn("marked config skipped:", e.message);
        } finally {
          logger.groupEnd();
        }
      };

      const configurePdfJs = async () => {
        logger.group("Configure PDF.js");
        try {
          const pdfjsLib = await waitForGlobal(
            "pdfjsLib",
            () => window.pdfjsLib || globalThis.pdfjsLib,
            WAIT_CONFIG.PDFJS
          );

          pdfjsLib.GlobalWorkerOptions.workerSrc =
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
          logger.debug("PDF.js workerSrc set.");
        } catch (e) {
          logger.warn("PDF.js config skipped:", e.message);
        } finally {
          logger.groupEnd();
        }
      };

      // ---- UI helpers ----
      const initTooltips = () => {
        logger.group("Initialize tooltips");
        try {
          const Tooltip = window.bootstrap?.Tooltip || globalThis.bootstrap?.Tooltip;

          if (!Tooltip) {
            logger.debug("bootstrap.Tooltip not yet available; will retry on window load.");
            addListener(window, "load", () => {
              const T = window.bootstrap?.Tooltip || globalThis.bootstrap?.Tooltip;
              if (!T) {
                return logger.warn("bootstrap.Tooltip still not found after load.");
              }
              initTooltipElements(T);
              logger.debug("Tooltips initialized after load.");
            }, { once: true });
            return;
          }

          initTooltipElements(Tooltip);
          logger.debug("Tooltips initialized.");
        } catch (e) {
          logger.error("Tooltip initialization failed:", e);
        } finally {
          logger.groupEnd();
        }
      };

      // ---- App init ---- 

      const initializeApp = async () => {
        logger.group("Initialize App");
        try {
          await timedStep("initElements", initElements);
          await timedStep("bindEvents", bindEvents);
          await timedStep("initRagFromModel", initRagFromModel);
          await timedStep("loadEmbeddingSourcesFromDB", loadEmbeddingSourcesFromDB);
          await timedStep("loadEnabledSources", loadEnabledSources);
          await timedStep("renderEmbeddingSourcesUI", renderEmbeddingSourcesUI);
          await timedStep('updateStatus("Ready")', () => updateStatus("Ready"));
          await timedStep("updateSendButtonState", updateSendButtonState);
          await timedStep("autoResize", autoResize);
          logger.info("Initialization sequence completed.");
        } catch (error) {
          logger.error("Failed to initialize chat app:", error);
          throw error;
        } finally {
          logger.groupEnd();
        }
      };

      // ---- Boot Orchestration ----

      let hasBooted = false;

      const boot = async () => {
        if (hasBooted) {
          logger.warn("Boot skipped: already booted.");
          return;
        }
        hasBooted = true;

        logger.group("Boot");
        try {
          // Configure third-party libraries
          await timedStep("configurePrism", configurePrism);
          await timedStep("configureMarked", configureMarked);
          await timedStep("configurePdfJs", configurePdfJs);

          // Initialize application
          await timedStep("initializeApp", initializeApp);
          await timedStep("initTooltips", initTooltips);

          logger.info("App Ready!");
        } catch (err) {
          logger.error("Boot failed:", err);
        } finally {
          logger.groupEnd();
        }
      };

      // ---- Entry Point ----

      // Boot when document is fully loaded
      if (document.readyState === "complete") {
        logger.debug("readyState=complete; booting immediately.");
        boot();
      } else {
        logger.debug(`readyState=${document.readyState}; waiting for 'load'.`);
        addListener(window, "load", () => {
          logger.debug("load event fired; starting boot.");
          boot();
        }, { once: true });
      }
    })();

  </script>
</body>
